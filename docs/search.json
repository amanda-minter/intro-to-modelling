[
  {
    "objectID": "calculus/differentiation.html",
    "href": "calculus/differentiation.html",
    "title": "Differentiation",
    "section": "",
    "text": "We will start with a basic question, what is the gradient of a line?\nThe three plots below each have three straight lines. The first has a positive gradient (or positive slope) i.e. as \\(x\\) increases so does \\(y.\\) The second has a negative gradient, as \\(x\\) increases \\(y\\) decreases. The third has a zero gradient, as \\(x\\) increases, there is no change in \\(y\\).\n\n\n\n\n\n\n\n\n\nLet’s look at some more examples.\n\n\n\n\n\n\n\n\n\nIn the plots above, the gradient of the line is not constant, so how can we find the gradient of these lines at different points? The answer is differentiation.\nDifferentiation is used to find the rate of change of one variable with respect to another. In these examples, the variables are \\(x\\) and \\(y\\) but we may instead be interested in a biological relationship, say population size \\(P\\) and time \\(t\\).\nThis idea of specifying the rate of change of one variable with respect to another is used in infectious disease and ecological modelling. As modellers, we specify the gradient of the relationship between two variables as a function of biological processes,then we find the equation of the line to predict how the variables change with each other.\nBefore we specify gradients as functions of biological processes, we will first learn how to find the gradient of the line from first principles."
  },
  {
    "objectID": "calculus/differentiation.html#motivation",
    "href": "calculus/differentiation.html#motivation",
    "title": "Differentiation",
    "section": "",
    "text": "We will start with a basic question, what is the gradient of a line?\nThe three plots below each have three straight lines. The first has a positive gradient (or positive slope) i.e. as \\(x\\) increases so does \\(y.\\) The second has a negative gradient, as \\(x\\) increases \\(y\\) decreases. The third has a zero gradient, as \\(x\\) increases, there is no change in \\(y\\).\n\n\n\n\n\n\n\n\n\nLet’s look at some more examples.\n\n\n\n\n\n\n\n\n\nIn the plots above, the gradient of the line is not constant, so how can we find the gradient of these lines at different points? The answer is differentiation.\nDifferentiation is used to find the rate of change of one variable with respect to another. In these examples, the variables are \\(x\\) and \\(y\\) but we may instead be interested in a biological relationship, say population size \\(P\\) and time \\(t\\).\nThis idea of specifying the rate of change of one variable with respect to another is used in infectious disease and ecological modelling. As modellers, we specify the gradient of the relationship between two variables as a function of biological processes,then we find the equation of the line to predict how the variables change with each other.\nBefore we specify gradients as functions of biological processes, we will first learn how to find the gradient of the line from first principles."
  },
  {
    "objectID": "calculus/differentiation.html#principle-of-differentiation",
    "href": "calculus/differentiation.html#principle-of-differentiation",
    "title": "Differentiation",
    "section": "Principle of differentiation",
    "text": "Principle of differentiation\nTo learn the concept of differentiation, we will start with a plot of two variables, \\(y\\) and \\(x\\).\n\n\n\n\n\n\n\n\n\nWe want to understand the relationship between \\(y\\) and \\(x\\), more specifically we want to quantify the gradient of the line. The gradient of the line is the rate of change of \\(y\\) with respect to \\(x\\).\nWe can see that the relationship is linear, therefore an appropriate equation for the line is \\[\ny = m x + c\n\\] where \\(c\\) is the intercept and \\(m\\) is the gradient (or slope) of the line.\nThe intercept is the the value of \\(y\\) when \\(x=0\\). In this example, we can read this value directly from the plot. When \\(x = 0\\), \\(y = 1\\). Therefore, \\(c = 1\\).\nThe gradient of the line is \\(m\\). This value represents how much \\(y\\) increases as a function of \\(x\\). We can find \\(m\\) using the following equation:\n\\[\n\\begin{aligned}\nm&= \\frac{\\mbox{change in $y$}}{\\mbox{change in $x$}} \\\\\n&= \\frac{y_2-y_1}{x_2-x_1}\n\\end{aligned}\n\\]\nwhere \\((x_1, y_1)\\) and \\((x_2, y_2)\\) are two points on the line. Hence \\(m\\) is the difference in two points on the \\(y\\) axis divided by the difference of the two corresponding points on the \\(x\\) axis. Evaluating the above equation will give us the gradient of the line between a pair of points.\nIn our example, let’s select 5 pairs of points along the line.\n\n\n\n\n\n\n\n\n\nwhere \\((x_1, y_1) = (0,1)\\).\nWe can calculate \\(m\\) using \\((x_1, y_1) = (0,1)\\) and \\((x_2, y_2) = (1,3)\\).\n\\[\n\\begin{aligned}\nm &= \\frac{y_2-y_1}{x_2-x_1} \\\\\n&= \\frac{3-1}{1-0} \\\\\n&= 2\n\\end{aligned}\n\\] The gradient of the line between the points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) is 2.\nLet’s repeat this calculation using two other points, \\((x_2, y_2) = (1,3)\\) and \\((x_4, y_4) = (4,9)\\).\n\\[\n\\begin{aligned}\nm &= \\frac{y_4-y_2}{x_4-x_2} \\\\\n&= \\frac{9-3}{4-1}\\\\\n&= \\frac{6}{3} \\\\\n&= 2\n\\end{aligned}\n\\] The gradient of the line between the points \\((x_2, y_2)\\) and \\((x_4, y_4)\\) is also 2.\nBecause all of the points fall on a straight line, the gradient is the same anywhere along the line.\nTherefore, our equation of the line is,\n\\[\ny = 2 x + 1.\n\\]\n\n\n\n\n\n\nExercise\n\n\n\nFind the value of \\(m\\) and \\(c\\) for the following line. Hint: find \\(m\\) first and use this to find \\(c\\) using \\(y = m x + c\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nUsing \\((x_1, y_1) = (1,8)\\) and \\((x_2, y_2) = (2,12)\\) \\[\n\\begin{aligned}\nm &= \\frac{y_2-y_1}{x_2-x_1} \\\\\n&= \\frac{12-8}{2-1} \\\\\n&= \\frac{4}{1} \\\\\n& = 4.\n\\end{aligned}\n\\] We have,\n\\[\ny = 4 x + c.\n\\]\nUsing, \\((x_1, y_1) = (1,8)\\)\n\\[\n\\begin{aligned}\ny_1 &= 4 x_1 + c \\\\\n8 &= 4 * 1 + c \\\\\nc& = 4.\n\\end{aligned}\n\\] Therefore,\n\\[\ny = 4 x + 4.\n\\]"
  },
  {
    "objectID": "calculus/differentiation.html#gradient-at-a-point",
    "href": "calculus/differentiation.html#gradient-at-a-point",
    "title": "Differentiation",
    "section": "Gradient at a point",
    "text": "Gradient at a point\nIn the previous lessons, we found the gradient between two points and then used this to find the equation of a straight line.\nWhat if we want to find the gradient at single point on the line? (instead of between two points)\nLet’s denote the point at which we want to find the gradient as \\(x\\), and denote some small difference along the \\(x\\) axis as \\(\\Delta x\\).\n\n\n\n\n\n\n\n\n\nIf we say \\(y = f(x)\\), then we can re-write \\(m\\) as follows,\n\\[\n\\begin{aligned}\nm &= \\frac{f(x+\\Delta x)-f(x)}{x+\\Delta x -x} \\\\\n&= \\frac{f(x+\\Delta x)-f(x)}{\\Delta x} \\\\\n\\end{aligned}\n\\]\nIn our first example, we had \\(y = 2 x + 1\\). Now we use the notation \\(f(x) = 2 x + 1\\). Therefore,\n\\[\n\\begin{aligned}\nm &= \\frac{f(x+\\Delta x)-f(x)}{x+\\Delta x -x} \\\\\n&= \\frac{(2(x+\\Delta x)+1)-(2x+1)}{\\Delta x} \\\\\n&= \\frac{2x+2\\Delta x+1-2x-1}{\\Delta x} \\\\\n&= \\frac{2\\Delta x}{\\Delta x} \\\\\n&= 2.\n\\end{aligned}\n\\] As before!\nWe have so far used \\(m\\) here to denote the gradient of a straight line, but we will not always be finding the gradient of a straight line. In general we are finding the rate of change of \\(y\\) with respect to \\(x\\), so we from now we will write the gradient as:\n\\[\n\\mbox{gradient} = \\frac{f(x+\\Delta x)-f(x)}{\\Delta x}\n\\]\nLet’s now look at an example of a more complex line. The plot below is of the function \\(y = x^2 + 4\\).\n\n\n\n\n\n\n\n\n\nLet’s find the equation for the gradient of the line for any point \\(x\\).\nHere we have \\(f(x)= x^2 + 4\\). Using our new definition of the gradient,\n\\[\n\\begin{aligned}\n\\mbox{gradient} &= \\frac{f(x+\\Delta x)-f(x)}{\\Delta x} \\\\\n& = \\frac{((x+\\Delta x)^2 +4)-(x^2+4)}{\\Delta x}  \\\\\n& = \\frac{x^2+2x\\Delta x +(\\Delta x)^2 +4-x^2-4}{\\Delta x}  \\\\\n& = \\frac{2x\\Delta x +(\\Delta x)^2}{\\Delta x}  \\\\\n&=2x +\\Delta x.\n\\end{aligned}\n\\] In this example, the \\(\\Delta x\\) has not been cancelled out. What we say instead is that as \\(\\Delta x\\) becomes smaller, the gradient gets closer and closer to \\(2x\\).\nWe write this using the mathematical symbol \\(\\to\\). If we write \\(\\Delta x\\to 0\\), this means that \\(\\Delta x\\) gets closer to \\(0\\) (also referred to as \\(\\Delta x\\) tends to \\(0\\)).\nThis leads us to the formal definition of a derivative,\n\\[\n\\frac{dy}{dx} =\\mbox{lim}_{\\Delta x\\to 0} \\frac{f(x+\\Delta x)-f(x)}{\\Delta x}\n\\] where \\(\\mbox{lim}\\) stands for “limit” i.e. what is the value of \\[\\frac{f(x+\\Delta x)-f(x)}{\\Delta x}\\] as \\(\\Delta x\\) tends to \\(0\\).\nIn this example, we have found that the derivative of \\(y = x^2 + 4\\) is \\(\\frac{dy}{dx} = 2x\\).\n\n\n\n\n\n\nFinding gradients at points\n\n\n\nWhen \\(x = -1\\), the gradient is \\(2x = -2\\) - a negative straight line.\nWhen is \\(x= 2\\), the gradient is \\(x = 4\\), a positive straight but also steeper.\n\nx &lt;- seq(-2, 2, l = 20)\ny &lt;- x^2 + 4\nplot(x, y, type = \"l\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExcercise\n\n\n\nFind the derivative of \\(y = 3 x^2\\) and hence find the gradient at \\(x =-1\\), \\(x=0\\) and \\(x=1\\).\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe derivative can be found as follows: \\[\n\\begin{aligned}\n\\frac{dy}{dx} &=\\mbox{lim}_{\\Delta x\\to 0} \\frac{f(x+\\Delta x)-f(x)}{\\Delta x} \\\\\n& = \\frac{3(x+\\Delta x)^2-3x^2}{\\Delta x}  \\\\\n& = \\frac{3(x^2+2x\\Delta x +(\\Delta x)^2)-3x^2}{\\Delta x} \\\\\n& = \\frac{3x^2+6x\\Delta x +3(\\Delta x)^2-3x^2}{\\Delta x} \\\\\n& = \\frac{6x\\Delta x +3(\\Delta x)^2}{\\Delta x}  \\\\\n&=6x +3\\Delta x \\\\\n& \\to 6x \\quad \\mbox{as} \\quad \\Delta x \\to 0.\n\\end{aligned}\n\\] At \\(x = -1\\), \\(\\frac{dy}{dx} = -6\\).\nAt \\(x = 0\\), \\(\\frac{dy}{dx} = 0\\).\nAt \\(x = 1\\), \\(\\frac{dy}{dx} = 6\\).\n\nx &lt;- seq(-2, 2, l = 20)\ny &lt;- 3 * x ^ 2\nplot(x, y, type = \"l\")"
  },
  {
    "objectID": "calculus/differentiation.html#general-rules-of-differentiation",
    "href": "calculus/differentiation.html#general-rules-of-differentiation",
    "title": "Differentiation",
    "section": "General rules of differentiation",
    "text": "General rules of differentiation\nEvery time we want to find the derivative of an equation, we don’t have to use the definition of derivative. Instead, we can use general rules of differentiation that have been derived from the definition.\nFor example, it can be shown using the definition that the derivative of the function \\(y = x^n\\) takes the form \\(\\frac{dy}{dx} = n x^{n-1}\\).\nThe function \\(y = x^2\\) is in the format \\(y = x^n\\) where \\(n=2\\). Hence the derivative is,\n\\[\n\\begin{aligned}\n\\frac{dy}{dx} & = n x^{n-1} \\\\\n& = 2 x^{2-1} \\\\\n& = 2x.\n\\end{aligned}\n\\]\nThe table below shows some common functions and their derivatives.\n\n\n\n\\(y=f(x)\\)\n\\(\\frac{dy}{dx}\\)\n\n\n\n\n\\(c\\)\n0\n\n\n\\(x\\)\n\\(1\\)\n\n\n\\(cx\\)\n\\(c\\)\n\n\n\\(x^n\\)\n\\(n x^{n-1}\\)\n\n\n\\(cx^n\\)\n\\(cn x^{n-1}\\)\n\n\n\\(e^x\\)\n\\(e^x\\)\n\n\n\\(e^cx\\)\n\\(ce^cx\\)\n\n\n\\(ln(x)\\)\n\\(\\frac{1}{x}\\)\n\n\n\\(ln(f(x))\\)\n\\(\\frac{1}{f(x)}\\frac{d f(x)}{dx}\\)\n\n\n\nAs well as these rules for certain functions, there are also rules for functions which take particular forms. For example, a function which consists of two functions divided by each together :\n\\[f(x) = \\frac{x^2}{e^x}.\\]\nFor functions such as this we would use what is called the quotient rule. If a function is of the form:\n\\[y = \\frac{f(x)}{g(x)}\\]\nusing the quotient rule, the derivative of \\(y\\) is:\n\\[\\frac{dy}{dx} = \\frac{f'(x) g(x)-f(x)g'(x)}{[g(x)]^2}\\]\nwhere \\(f'(x)\\) is the derivative of \\(f(x)\\) and \\(g'(x)\\) is the derivative of \\(g(x)\\)."
  },
  {
    "objectID": "calculus/differentiation.html#summary",
    "href": "calculus/differentiation.html#summary",
    "title": "Differentiation",
    "section": "Summary",
    "text": "Summary\nWe have spent some time understanding the concept of differentiation from first principles. In ecological and epidemiological modelling, we will use differentiation in the form of ordinary differential equations. Here we will specify the derivative of a function in terms of biological processes.\nThis means that as well as understanding how to obtain the derivative of a function, we also need to understand how to obtain a function from it’s derivative. We do this using integration."
  },
  {
    "objectID": "calculus/integration.html",
    "href": "calculus/integration.html",
    "title": "Integration",
    "section": "",
    "text": "Integration is used to find the anti-derivative. Previously, from a function \\(y=f(x)\\) we found the derivative \\(\\frac{dy}{dx}\\) using differentiation. Now, starting from the derivative \\(\\frac{dy}{dx}\\) we will find \\(y=f(x)\\) using integration.\nLet’s start by introducing two pieces of new notation:\nWe will integrate the function ‘inside’ the integral sign \\(\\int\\) and with respect to the variable after \\(d\\), for example we had a function \\(y=f(x)\\) and the derivative is \\(\\frac{dy}{dx} = f'(x)\\).\nThen \\(\\int f'(x) dx = f(x)\\).\nIf instead our function was written with the variable \\(t\\) instead of \\(x\\), we would have \\(y=f(t)\\), with derivative \\(\\frac{dy}{dt} = f'(t)\\) and \\(\\int f'(t) dt = f(t)\\)."
  },
  {
    "objectID": "calculus/integration.html#separation-of-variables",
    "href": "calculus/integration.html#separation-of-variables",
    "title": "Integration",
    "section": "Separation of variables",
    "text": "Separation of variables\nJust as there are differentiation rules, there are also integration rules. Hopefully from the previous exercises you would have found that you can find the integral of a function using what you know about differentiation.\nThere are some cases in which we need to know specific integration rules. In this lesson, we will learn the ‘separation of variables’ method, as this will be needed in our first ecological model : population growth.\nConsider the derivative,\n\\[ \\frac{dy}{dx} = 5y.\\]\nWhy is this different to the derivatives we have seen before?\nOn the right hand side of the equation we have \\(y\\) and not \\(x\\). Therefore, we cannot simply find the derivative as before. To solve this equation we will need to ‘separate the variables’. We shall do this in steps.\n\nSeparate the variables\n\nWe move all of the terms including \\(y\\) to the left hand side of the equation, and all the terms including \\(x\\) to the right hand side of the equation. To this we multiply by \\(dx\\):\n\\[ dy = 5y dx\\] and then divide by \\(y\\)\n\\[ \\frac{1}{y} dy = 5 dx.\\]\nNow we have all terms including \\(y\\) on the left hand side, and all terms including \\(x\\) on the right hand side.\n\nIntegrate both sides\n\nThe next step is to integrate both sides of the equation:\n\\[ \\int \\frac{1}{y} dy = \\int 5 dx\\] We shall integrate the right hand side first,\n\\[ \\int \\frac{1}{y} dy =  5x + c_1 \\]\nwhere \\(c_1\\) is our constant of integration. Next the left hand side,\n\\[ \\ln(y) + c_2 =  5x + c_1\\] where \\(c_2\\) is also a constant of integration, but this time from the left hand side of the equation.\n\nSimplify the solution\n\nWe can tidy up the solution by moving \\(c_2\\) to the right hand side,\n\\[ \\ln(y) =  5x + c_1 - c_2.\\]\nThen take the exponent of both sides (note that \\(e^{ln(y)} = y\\)).\n\\[ y =  e^{5x + c_1 - c_2}.\\]\nWe can substitute \\(c = c_1 - c_2,\\)\n\\[ y =  e^{5x + c}\\]\nThen separate the two terms within the exponent:\n\\[ y =  e^{5x}e^{c}.\\]\nThe term \\(e^c\\) is a constant, as it does not contain \\(x\\), therefore we can write \\(C=e^{x}\\)\n\\[ y =  e^{5x}C.\\]\nTherefore, the solution to \\(\\frac{dy}{dx} = 5y\\) is \\(y = e^{5x}C\\)."
  },
  {
    "objectID": "calculus/numerical_integration.html",
    "href": "calculus/numerical_integration.html",
    "title": "Numerical integration",
    "section": "",
    "text": "In our previous examples we have been able to find an analytical solution to the population growth ODEs (with and without carrying capacity). This means we have been able to write down an equation for the solution. However in some cases, it can be very difficult or impossible to find an analytical solution to an ODE. In these cases we use methods to find a numerical approximation of the analytical solution.\nIn the next lessons we will learn the principles of finding a numerical approximation to ODEs."
  },
  {
    "objectID": "calculus/numerical_integration.html#the-euler-method",
    "href": "calculus/numerical_integration.html#the-euler-method",
    "title": "Numerical integration",
    "section": "The Euler method",
    "text": "The Euler method\nFirst we will revisit some notation of derivatives and integrals. We denoted the derivative of a function as:\n\\[\\frac{dy}{dt}= f'(t)\\]\nthen integrating \\(f'(t)\\) gave us \\(f(t)\\):\n\\[\\int f'(t) dt = f(t).\\]\nFor the population growth case, we have \\(\\frac{dP}{dt}= r P\\) and we are interested in finding \\(P(t) = f(t)\\).\nWe start with the definition of a derivative for our ODE \\(\\frac{dP}{dt}\\):\n\\[\\frac{dP}{dt} =\\mbox{lim}_{\\Delta t\\to 0} \\frac{f(t+\\Delta t)-f(t)}{\\Delta t}\\]\nInstead of looking at the limit as \\(\\Delta t\\) goes to 0, we instead assume that for very small \\(\\Delta t\\) that the left hand side is approximately equal to the right hand side:\n\\[\\frac{dP}{dt} \\approx \\frac{f(t+\\Delta t)-f(t)}{\\Delta t}.\\]\nWe are trying to find the solution \\(P(t)\\), so we can substitute \\(f(t)\\) with \\(P(t)\\).\n\\[\\frac{dP}{dt} \\approx \\frac{P(t+\\Delta t)-P(t)}{\\Delta t}\\]\nOur goal is to rearrange this equations so we have \\(P(t+\\Delta t)\\) on the left hand side. First we can multiply both sides by \\(\\Delta t\\):\n\\[\\frac{dP}{dt} \\Delta t \\approx P(t+\\Delta t)-P(t)\\]\nthen we add \\(P(t)\\) to both sides:\n\\[\\frac{dP}{dt} \\Delta t + P(t) \\approx P(t+\\Delta t)\\] which we can rewrite as: \\[P(t+\\Delta t)\\approx P(t) + \\frac{dP}{dt} \\Delta t \\] where we can write \\(\\frac{dP}{dt} = r P(t).\\)\nNow we have a method to approximate the value of the solution at one time step in the future \\(t+\\Delta t\\).\nWe wish to find a numerical approximation from time 0 to the maximum time \\(t_{max}\\). We rewrite the above equation in the more general form:\n\\[ P_{n+1} = P_{n} + (r P_{n})  \\Delta t. \\] for time steps \\(n = 0, 1, 2, \\cdots, n_{max}\\) where \\(t_{n+1} = t_n + \\Delta t\\) and \\(n_{max}\\) is the total number of time steps.\nThis is called the Euler method.\nThe Euler method works by forward calculating the value of the solution in between time steps \\(t\\) and \\(t+\\Delta t\\) using the gradient, \\(\\frac{dP}{dt}\\). The accuracy of the numerical solution can depend on the time step size, we will see this in practice in the next lesson."
  },
  {
    "objectID": "calculus/numerical_integration.html#the-euler-method-in-r",
    "href": "calculus/numerical_integration.html#the-euler-method-in-r",
    "title": "Numerical integration",
    "section": "The Euler method in R",
    "text": "The Euler method in R\nTo find the numerical approximation at each time step we will use a for loop in R. We will specify \\(\\Delta t = 1\\), i.e. daily time steps. The code below assigns the parameter values, sets up an empty data frame solution to store our approximation and then finds the numerical approximation at each time step and stores the value in the data frame solution.\n\n# Assign parameter values\nP_0 &lt;- 1\nr   &lt;- 0.2\n\n# Calculate the number of time steps\ndelta_t &lt;- 1\nt_max &lt;- 50\nn_max &lt;- t_max / delta_t\n\n# Set up empty data frame to store time and value of P\nsolution &lt;- data.frame(time = 0, P = P_0)\n\n# For n time steps\nfor (n in 1:n_max){\n  # Find the current time\n  time &lt;- solution$time[n]\n  # Find the current value of P\n  P &lt;- solution$P[n]\n  # Calculate the next value of P\n  next_P &lt;- P + (r * P) * delta_t\n  # Store the time and the next value of P\n  solution[(n + 1), ] &lt;- c(time + delta_t, next_P)\n}\n\nplot(solution$time, solution$P, pch = 19, col = \"navy\")\nlegend(\"topleft\", c(\"Approximation\"), col = \"navy\", pch = 19, bty = \"n\")\n\n\n\n\nWe have used the Euler method to find a numerical approximation of the solution to \\(\\frac{dP}{dt}\\) at time steps of one day."
  },
  {
    "objectID": "calculus/numerical_integration.html#comparison-to-analytical-solution",
    "href": "calculus/numerical_integration.html#comparison-to-analytical-solution",
    "title": "Numerical integration",
    "section": "Comparison to analytical solution",
    "text": "Comparison to analytical solution\nIn the case of the population growth ODE, we do have the exact equation of the analytical solution, so we can compare our numerical approximation to the exact solution. Recall that the equation for the solution is \\[P(t)= P(0) e^{rt}.\\]\nThe plot below shows the analytical solution and the numerical approximation using \\(\\Delta t = 1\\).\n\n\n\n\n\nThe numerical approximation does not exactly match the exact solution.\nIf we look at the plot, we can see that when the population starts to grow more quickly, the approximation does not equal the true solution. What happens if we decrease the time step to \\(\\Delta t = 0.1\\)?\n\n\n\n\n\nNow the numerical approximation more closely matches the analytical solution.\nDecreasing the time step improved the accuracy of our approximation. However, if we wanted to find the solution over a longer time period, more computation time would be needed. The Euler method is a very simple approximation, we can improve our numerical solution with a more complex method."
  },
  {
    "objectID": "calculus/numerical_integration.html#rungekutta-methods",
    "href": "calculus/numerical_integration.html#rungekutta-methods",
    "title": "Numerical integration",
    "section": "Runge–Kutta methods",
    "text": "Runge–Kutta methods\nThe Runge–Kutta method, also known as RK4, is a method for finding a numerical solution of an integral.\nIn our Euler example, we used the expression for the derivative \\(\\frac{dP}{dt}\\), to calculate the slope of our line at each time step. RK4 uses a similar principle, but instead of calculating one slope, RK4 calculates four different slopes (hence the name!).\nFor our population growth example, the RK4 method is as follows,\n\\[P_{n+1} = P_n + \\frac{1}{6} h (k_1 + 2k_2 + 2k_3 + k_4)\\]\nwhere \\(h = \\Delta t\\) our step size and \\(\\frac{dP}{dt}= f'(t,P)\\),\n\\[\n\\begin{aligned}\nk_1 & = f'(t_n, P_n)\\\\\nk_2 & = f'(t_n + \\frac{h}{2}, P_n +\\frac{h}{2} k_1) \\\\\nk_3 & = f'(t_n + \\frac{h}{2}, P_n+ \\frac{h}{2}k 2) \\\\\nk_4 & = f'(t_n + h, P_n + hk_3). \\\\\n\\end{aligned}\n\\]\nYou may notice that the value \\(k_1\\) is the Euler method calculation. The remaining values are the calculations of gradients at different points within the interval \\(t\\) and \\(t+\\Delta t\\).\nTo implement RK4 in R, we are going to use the calculation \\(f'(t,P)\\) multiple times, therefore we will write an R function to perform the calculation. Then as before, we will use a for loop to calculate the value of our numerical approximation at each time step, this time we calculate \\(k_1\\), \\(k_2\\), \\(k_3\\) and \\(k_4\\) at each iteration.\n\n# Function to calculate and return slope\nfun &lt;- function(t, P) {\n  r * P\n}\n\n# Assign parameter values\nP_0 &lt;- 1\nr   &lt;- 0.2\n\n# Calculate the number of time steps\ndelta_t &lt;- 1\nh &lt;- delta_t\ntmax &lt;- 50\nn_steps &lt;- tmax / delta_t\n\n# Set up empty data frame to store time and value of P\nsolution &lt;- data.frame(time = 0, P = P_0)\n\n# for n_max time steps\nfor (n in 1:n_steps){\n  # Find the current time\n  time &lt;- solution$time[n]\n  # Find the current value of P\n  P &lt;- solution$P[n]\n  # Calculate the values of the increments\n  k1 &lt;- fun(time, P)\n  k2 &lt;- fun(time + h / 2, P + h / 2 * k1)\n  k3 &lt;- fun(time + h / 2, P + h / 2 * k2)\n  k4 &lt;- fun(time + h, P + h * k3)\n  # Calculate the next value of P\n  next_P &lt;- P + (1 / 6 * h * (k1 + 2 * k2 + 2 * k3 + k4))\n  # Store the time and the next value of P\n  solution[(n + 1), ] &lt;- c(time + h, next_P)\n}\n\n# Find the value of P over time using the analytical solution\ntimes   &lt;- seq(from = 0, to = tmax, by = h)\nP_t &lt;- P_0 * exp(r * times)\n\nplot(times, P_t)\npoints(solution$time, solution$P, pch = 17, col = \"orange\")\nlegend(\"topleft\", c(\"Approximation (rk4)\", \"Exact\"),\n       col = c(\"orange\", \"black\"), pch = c(17, 1), bty = \"n\")\n\n\n\n\nFrom the plot we can see that the RK4 approximation using daily time steps (\\(\\Delta t = 1\\)) gives a very close approximation to the analytical solution.\nWe have learnt how to write our own code to perform numerical integration, but in practice we can use an R package."
  },
  {
    "objectID": "calculus/numerical_integration_2.html",
    "href": "calculus/numerical_integration_2.html",
    "title": "Numerical integration : Using deSolve",
    "section": "",
    "text": "In this lesson we will learn how to use an ODE solver in the R package deSolve to find numerical approximations of solutions to ODEs. The first step is to install and load the package.\n\ninstall.packages(\"deSolve\")\nlibrary(deSolve)\n\nThe function we will use to find our numerical solution is called ode. There are a number of inputs to this function, we will need to specify the first five:\node(y, times, func, parms, method).\nLet’s look at these inputs in detail for the population growth ODE \\(\\frac{dP}{dt} = r P\\).\nThe first input is the initial state value for our ODE. Here we will assume that the initial population size is 1.\nWe will put this values into a vector called state_var as follows:\nstate_var &lt;- c(P = 1).\nThe second input is the times over which we want to find our numerical solution for. Assuming our parameter values are daily rates, we will create a sequence of values starting from day 0 to day 50 at increments of one day. Our time vector is: times &lt;- seq(from = 0, to = 50, by = 1)\nThe third input is func, an R function which describes the system of ODEs. The function itself has to be specified with three inputs:\n\nthe current time\nthe current value of the state variable\nthe vector of parameters\n\nand the function must return a list, where the first element is a vector of the derivative values.\nThe function below describes the system of ODEs for the predator-prey model. It takes inputs time, state_var and pars and returns our derivative values dP in a vector.\n\npopulation_growth &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  P &lt;- state_var[\"P\"]\n  # Extract model parameters\n  r &lt;- pars[\"r\"]\n  # The differential equations\n  dP &lt;- r * P\n  # Return the derivative as a list\n  sol &lt;- list(c(dP))\n  return(sol)\n}\n\nThe fourth input is the vector of parameter values. In the population growth model, we have just one parameter, we add these to a vector named pars : pars &lt;- c(r = 0.2).\nThe fifth input is the method to be used to find the numerical solution. We will specify our method as euler.\n\n# What are our parameter values?\npars &lt;- c(r = 0.2)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c(P = 1)\n\n# Solve the equations over the vector of times with initial conditions\nsolution_desolve &lt;- ode(y = state_var, times = times, func = population_growth,\n                        parms = pars, method = euler)\n\n# Convert to a data frame to extract columns by name\nsolution_desolve &lt;- as.data.frame(solution_desolve)\nhead(solution_desolve)\n\n  time       P\n1    0 1.00000\n2    1 1.20000\n3    2 1.44000\n4    3 1.72800\n5    4 2.07360\n6    5 2.48832\n\n\nThe solution consists of the time and the solution of our ODE at that time point.\nLet’s compare our results from the R function ode to our Euler solver from the previous lesson:\n\n# Assign parameter values\nP_0 &lt;- 1\nr   &lt;- 0.2\n\n# Calculate the number of time steps\ndelta_t &lt;- 1\nt_max &lt;- 50\nn_max &lt;- t_max / delta_t\n\n# Set up empty data frame to store time and value of P\nsolution &lt;- data.frame(time = 0, P = P_0)\n\n# for n_max time steps\nfor (n in 1:n_max){\n  # Find the current time\n  time &lt;- solution$time[n]\n  # Find the current value of P\n  P &lt;- solution$P[n]\n  # Calculate the next value of P\n  next_P &lt;- P + (r * P) * delta_t\n  # Store the time and the next value of P\n  solution[(n + 1), ] &lt;- c(time + delta_t, next_P)\n}\n\nplot(solution_desolve$time, solution_desolve$P, type = \"b\", pch = 5,\n     xlab = \"Time\", ylab = \"Number\")\npoints(solution$time, solution$P, pch = 19, col = \"navy\")\nlegend(\"topleft\", c(\"Our code\", \"deSolve\"), col = c(\"navy\", \"black\"),\n       pch = c(19, 5), bty = \"n\")\n\n\n\n\nAs expected, the values are the same.\nAs before, we can decrease our time step to improve the accuracy of our numerical solution. To do this, we must change the by argument in our times vector.\n\ntimes_01 &lt;- seq(from = 0, to = 50, by = 0.1)\n\nsolution_01 &lt;- as.data.frame(ode(y = state_var, times = times_01,\n                                  func = population_growth, parms = pars,\n                                  method = euler))\n\nTo use the RK4 method, we simply change the method argument in ode to rk4.\n\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\nsolution_rk4 &lt;- as.data.frame(ode(y = state_var, times = times,\n                                  func = population_growth, parms = pars,\n                                  method = rk4))\n\n\n\n\n\n\n\nExercise\n\n\n\nUsing the population growth ODE function from the previous lesson, extend the code to find the solution of the population growth model with carrying capacity with \\(r=0.2\\), \\(K=50\\) and \\(P(0)=1\\). Recall that the ODE is,\n\\[\n\\begin{aligned}\n\\frac{dP}{dt} & = r P \\frac{(K-P)}{K}\n\\end{aligned}\n\\] where \\(r\\) is the growth rate and \\(K\\) is the carrying capacity.\nUse the function ode to find the solution and plot the solution.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTo extend the population growth function make the following changes,\n\nextract the parameter \\(K\\)\nadd the carrying capacity terms to the line dP.\n\n\npopulation_growth_K &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  P &lt;- state_var[\"P\"]\n  # Extract model parameters\n  r &lt;- pars[\"r\"]\n  K &lt;- pars[\"K\"]\n  # The differential equations\n  dP &lt;- r * P * ((K - P) / K)\n  # Return the equations as a list\n  sol &lt;- list(c(dP))\n  return(sol)\n}\n\nTo find the solution, we must add \\(K = 50\\) to our parameter vector.\n\n# What are our parameter values?\npars &lt;- c(r = 0.2, K = 50)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c(P = 1)\n\n# Solve the equations over the vector of times with initial conditions\nsolution &lt;- as.data.frame(ode(y = state_var, times = times,\n                              func = population_growth_K, parms = pars,\n                              method = rk4))\nplot(solution$time, solution$P, type = \"b\", pch = 5,\n     xlab = \"Time\", ylab = \"Number\")\n\n\n\n\nNote : We convert the output from ode() to a data frame so we can extract column names for plotting."
  },
  {
    "objectID": "calculus/numerical_integration_2.html#using-desolve",
    "href": "calculus/numerical_integration_2.html#using-desolve",
    "title": "Numerical integration : Using deSolve",
    "section": "",
    "text": "In this lesson we will learn how to use an ODE solver in the R package deSolve to find numerical approximations of solutions to ODEs. The first step is to install and load the package.\n\ninstall.packages(\"deSolve\")\nlibrary(deSolve)\n\nThe function we will use to find our numerical solution is called ode. There are a number of inputs to this function, we will need to specify the first five:\node(y, times, func, parms, method).\nLet’s look at these inputs in detail for the population growth ODE \\(\\frac{dP}{dt} = r P\\).\nThe first input is the initial state value for our ODE. Here we will assume that the initial population size is 1.\nWe will put this values into a vector called state_var as follows:\nstate_var &lt;- c(P = 1).\nThe second input is the times over which we want to find our numerical solution for. Assuming our parameter values are daily rates, we will create a sequence of values starting from day 0 to day 50 at increments of one day. Our time vector is: times &lt;- seq(from = 0, to = 50, by = 1)\nThe third input is func, an R function which describes the system of ODEs. The function itself has to be specified with three inputs:\n\nthe current time\nthe current value of the state variable\nthe vector of parameters\n\nand the function must return a list, where the first element is a vector of the derivative values.\nThe function below describes the system of ODEs for the predator-prey model. It takes inputs time, state_var and pars and returns our derivative values dP in a vector.\n\npopulation_growth &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  P &lt;- state_var[\"P\"]\n  # Extract model parameters\n  r &lt;- pars[\"r\"]\n  # The differential equations\n  dP &lt;- r * P\n  # Return the derivative as a list\n  sol &lt;- list(c(dP))\n  return(sol)\n}\n\nThe fourth input is the vector of parameter values. In the population growth model, we have just one parameter, we add these to a vector named pars : pars &lt;- c(r = 0.2).\nThe fifth input is the method to be used to find the numerical solution. We will specify our method as euler.\n\n# What are our parameter values?\npars &lt;- c(r = 0.2)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c(P = 1)\n\n# Solve the equations over the vector of times with initial conditions\nsolution_desolve &lt;- ode(y = state_var, times = times, func = population_growth,\n                        parms = pars, method = euler)\n\n# Convert to a data frame to extract columns by name\nsolution_desolve &lt;- as.data.frame(solution_desolve)\nhead(solution_desolve)\n\n  time       P\n1    0 1.00000\n2    1 1.20000\n3    2 1.44000\n4    3 1.72800\n5    4 2.07360\n6    5 2.48832\n\n\nThe solution consists of the time and the solution of our ODE at that time point.\nLet’s compare our results from the R function ode to our Euler solver from the previous lesson:\n\n# Assign parameter values\nP_0 &lt;- 1\nr   &lt;- 0.2\n\n# Calculate the number of time steps\ndelta_t &lt;- 1\nt_max &lt;- 50\nn_max &lt;- t_max / delta_t\n\n# Set up empty data frame to store time and value of P\nsolution &lt;- data.frame(time = 0, P = P_0)\n\n# for n_max time steps\nfor (n in 1:n_max){\n  # Find the current time\n  time &lt;- solution$time[n]\n  # Find the current value of P\n  P &lt;- solution$P[n]\n  # Calculate the next value of P\n  next_P &lt;- P + (r * P) * delta_t\n  # Store the time and the next value of P\n  solution[(n + 1), ] &lt;- c(time + delta_t, next_P)\n}\n\nplot(solution_desolve$time, solution_desolve$P, type = \"b\", pch = 5,\n     xlab = \"Time\", ylab = \"Number\")\npoints(solution$time, solution$P, pch = 19, col = \"navy\")\nlegend(\"topleft\", c(\"Our code\", \"deSolve\"), col = c(\"navy\", \"black\"),\n       pch = c(19, 5), bty = \"n\")\n\n\n\n\nAs expected, the values are the same.\nAs before, we can decrease our time step to improve the accuracy of our numerical solution. To do this, we must change the by argument in our times vector.\n\ntimes_01 &lt;- seq(from = 0, to = 50, by = 0.1)\n\nsolution_01 &lt;- as.data.frame(ode(y = state_var, times = times_01,\n                                  func = population_growth, parms = pars,\n                                  method = euler))\n\nTo use the RK4 method, we simply change the method argument in ode to rk4.\n\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\nsolution_rk4 &lt;- as.data.frame(ode(y = state_var, times = times,\n                                  func = population_growth, parms = pars,\n                                  method = rk4))\n\n\n\n\n\n\n\nExercise\n\n\n\nUsing the population growth ODE function from the previous lesson, extend the code to find the solution of the population growth model with carrying capacity with \\(r=0.2\\), \\(K=50\\) and \\(P(0)=1\\). Recall that the ODE is,\n\\[\n\\begin{aligned}\n\\frac{dP}{dt} & = r P \\frac{(K-P)}{K}\n\\end{aligned}\n\\] where \\(r\\) is the growth rate and \\(K\\) is the carrying capacity.\nUse the function ode to find the solution and plot the solution.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nTo extend the population growth function make the following changes,\n\nextract the parameter \\(K\\)\nadd the carrying capacity terms to the line dP.\n\n\npopulation_growth_K &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  P &lt;- state_var[\"P\"]\n  # Extract model parameters\n  r &lt;- pars[\"r\"]\n  K &lt;- pars[\"K\"]\n  # The differential equations\n  dP &lt;- r * P * ((K - P) / K)\n  # Return the equations as a list\n  sol &lt;- list(c(dP))\n  return(sol)\n}\n\nTo find the solution, we must add \\(K = 50\\) to our parameter vector.\n\n# What are our parameter values?\npars &lt;- c(r = 0.2, K = 50)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c(P = 1)\n\n# Solve the equations over the vector of times with initial conditions\nsolution &lt;- as.data.frame(ode(y = state_var, times = times,\n                              func = population_growth_K, parms = pars,\n                              method = rk4))\nplot(solution$time, solution$P, type = \"b\", pch = 5,\n     xlab = \"Time\", ylab = \"Number\")\n\n\n\n\nNote : We convert the output from ode() to a data frame so we can extract column names for plotting."
  },
  {
    "objectID": "calculus/ODE.html",
    "href": "calculus/ODE.html",
    "title": "Ordinary differential equations",
    "section": "",
    "text": "Ordinary differential equations can be used to model the rate of change of one variable with respect to another. They are often used in epidemic and ecological modelling as it allows us to specify the processes which affect the rate of change of populations.\nAn ordinary differential equation (ODE) is an equation involving an unknown function of one variable and its derivatives.\nFor example, \\(\\frac{dy}{dx} = 2x\\) is an ODE. We use the terminology “solving” the ODE, to find a “solution”. To solve the ODE \\(\\frac{dy}{dx} = 2x\\) we integrate to find the solution \\(y=x^2 +c\\).\nIn the next lessons we will write on ODE to describe population growth, solve the ODE and plot the solution."
  },
  {
    "objectID": "calculus/ODE.html#population-growth",
    "href": "calculus/ODE.html#population-growth",
    "title": "Ordinary differential equations",
    "section": "Population growth",
    "text": "Population growth\nWe want to predict population size over time. The population changes according to two processes: births and deaths. The schematic below represents our model in the form of a flow diagram.\n\n\n\n\n\nFirst, we can write down our assumptions from our flow diagram using words: \\[\n\\begin{aligned}\n\\mbox{ population rate of change} & = + \\mbox{births} - \\mbox{deaths} \\\\\n\\end{aligned}\n\\] The population will increase with births and decrease with deaths.\nWe denote the number of people in the population \\(P\\). We refer to \\(P\\) the state variable of the ODE.\nOur model will have two parameters, the birth rate \\(b\\) and the death rate \\(m\\). The birth rate represents the rate of new births per individual per time step. For example, if \\(b=0.1\\) and the current population size is \\(P = 10\\), the new births are \\(bP=1\\).\nOur notation for the rate of change with respect to time is \\(dP/dt\\), therefore our ODE model is:\n\\[\n\\begin{aligned}\n\\frac{dP}{dt} & = b P - m P\n\\end{aligned}\n\\]\nWe can simplify this equation by writing the overall growth rate \\(r\\) as the difference between the birth and death rate, \\(r = b - m\\).\n\\[\n\\begin{aligned}\n\\frac{dP}{dt} & = r P\n\\end{aligned}\n\\]\nTo find the solution to this ODE, we must integrate."
  },
  {
    "objectID": "calculus/ODE.html#population-growth-solution",
    "href": "calculus/ODE.html#population-growth-solution",
    "title": "Ordinary differential equations",
    "section": "Population growth solution",
    "text": "Population growth solution\nTo find the solution to the population growth ODE we will use the separation of variables method.\n\nSeparate the variables.\n\nWe move all of the terms including \\(P\\) to the left hand side of the equation, and all the terms including \\(t\\) to the right hand side of the equation. To this we multiply by \\(dt\\):\n\\[ dP = r P dt\\] and then divide by \\(P\\),\n\\[\\frac{1}{P} dP  = r dt\\] 2. Integrate both sides\n\\[\n\\begin{align}\n\\int \\frac{1}{P} dP & = \\int r dt \\\\\n\\ln(P) & =  r t + c\n\\end{align}\n\\]\nwhere \\(c\\) is the constant from both sides.\n\nSimplify the solution\n\nThen take the exponent of both sides and separate out the constant.\n\\[\n\\begin{align}\nP & =  \\exp(r t + c) \\\\\n& =  \\exp(r t) \\exp(c) \\\\\n\\end{align}\n\\]\nTo find a value for the constant, we substitute \\(t=0\\),\n\\[\n\\begin{aligned}\nP(0)  &=  \\exp(0) \\exp(c) \\\\\n&= \\exp(c)\n\\end{aligned}\n\\] Therefore we can write the constant \\(\\exp(c)\\) with the value of the state variable at time 0,\n\\[\n\\begin{aligned}\nP(t)  &=  \\exp(r t) P(0) \\\\\n&= P(0) e^{rt}.\n\\end{aligned}\n\\]\nThe population size at time \\(t\\), can be found using the above equation given an initial value of the population at time 0 \\(P(0)\\) and the growth rate \\(r\\).\n\nPlotting the solution\nWe have our solution \\(P(t)= P(0) e^{rt}\\). To plot the solution we need the following,\n\nthe initial state \\(P(0)\\) is the value of our state variable at time 0,\nthe growth rate of parameter \\(r\\),\nthe time we wish to find the solution for \\(t\\).\n\nWe assume the population size starts at 1 so we have \\(P(0)=1\\), and grows at rate \\(r = 0.2\\). In R we assign these values as follows.\n\n# Set the initial condition P(0) =1\nP_0 &lt;- 1\n# Set growth rate r = 0.2\nr &lt;- 0.2\n\nWe will find the solution for 50 time points.\n\n# Specify the time t which we want to plot the solution\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# Find the population at time t using the solution to the ODE\nP_t &lt;- P_0 * exp(r * times)\n\n# Plot the solution\nplot(times, P_t, xlab = \"Time\", ylab = \"Population size\", lwd = 2)\n\n\n\n\n\n\n\n\nWe will see later in the course that we cannot always find an equation for the solution to the ODE (this is called the analytical solution), instead we have to perform numerical integration to find the solution.\n\n\nEquilibrium states\nEquilibrium states (or points) occur when a system is at equilibrium i.e. there are no changes to the state variable values. An equilibrium state for a differential equation is a solution where the value of the state variables does not change over time.\nRecall when the derivative of a line is 0, the gradient is 0 - which means that the line is flat. Given that differential equations represent the rate of change of a state variable, when a differential equation is 0 - there is no change in the state variable, the gradient of the solution of the ODE is 0.\nIn epidemic and ecological modelling we are interested if our ODE or ODEs have equilibrium states, what values they take and what conditions lead to the model reaching equilibrium. In the next lesson we will consider an extension to the population growth model which as an equilibrium state.\n\n\nPopulation growth with carrying capacity\nIn our previous example, we formulated an ODE to describe population growth. In the solution, the population grew exponentially. A more realistic model of population growth will include some kind of limit to the population size.\nThe ODE below describes a population growth with a ‘carrying capacity’ \\(K\\). \\[\n\\begin{aligned}\n\\frac{dP}{dt} & = r P \\frac{(K-P)}{K}.\n\\end{aligned}\n\\] To further understand this equation, consider the following questions:\n\n\n\n\n\n\nIf \\(K&gt;P\\), is \\(\\frac{dP}{dt}\\) positive or negative?\n\n\n\n\n\n\\(\\frac{dP}{dt}\\) is positive, the population size is growing with respect to time because the population has not reached its carrying capacity\n\n\n\n\n\n\n\n\n\nIf \\(K&lt;P\\), is \\(\\frac{dP}{dt}\\) positive or negative?\n\n\n\n\n\n\\(\\frac{dP}{dt}\\) is negative, the population size is decreasing with respect to time as the population size is above its carrying capacity\n\n\n\n\n\n\n\n\n\nIf \\(K=P\\), what does \\(\\frac{dP}{dt}\\) equal?\n\n\n\n\n\n\\(\\frac{dP}{dt}=0\\), the population is at is carrying capacity and does not grow in size or decrease\n\n\n\nTo explore the dynamics of this model, we need to find the solution to the ODE.\n\n\nPopulation growth model equilibrium states\nWe can find a solution by hand (an analytical solution), but it’s more challenging than the population growth equation without carrying capacity. We won’t focus on the steps of finding the solution here, instead we will focus on the behaviour of the model.\nThe solution to the ODE is,\n\\[\nP(t) = \\frac{K}{1+Ae^{-rt}} \\quad \\mbox{where } A=\\frac{K-P_0}{P_0}\n\\] where \\(P_0 = P(0)\\), the initial population size at time \\(t=0\\).\nWe can plot the solution for given initial condition \\(P(0)\\), growth rate \\(r\\), and carrying capacity \\(K\\).\nBefore we do this, what do you think the equilibrium points will be? In other words, when will \\(\\frac{dP}{dt}=0\\)?\nLet’s return to the ODE equation,\n\\[\n\\begin{aligned}\n\\frac{dP}{dt} & = r P \\frac{(K-P)}{K}\n\\end{aligned}\n\\] The gradient is 0 when this expression is equal to 0 i.e. \\(\\frac{dP}{dt}=0\\). For what values of the state variables and parameters is this expression equal to?\nLet’s first expand the terms on the right hand side of the equation: \\[\n\\begin{aligned}\n\\frac{dP}{dt} & = r P \\frac{(K-P)}{K} \\\\\n&=r P - \\frac{r P^2}{K}\n\\end{aligned}\n\\]\nIf we set the left hand side of the equation to 0, we have:\n\\[\n\\begin{aligned}\n0&=r P - \\frac{r P^2}{K}  \\\\\nr P K &= r P^2\n\\end{aligned}\n\\] When does the left hand side of the equation equal the right hand side of the equation?\n\n\\(P=0\\) the population size is 0,\n\\(P=K\\) the population at carrying capacity.\n\nLet’s consider each of these in turn.\nThe first case is when the population size is 0, we replicate this by setting the initial state to 0.\n\n# Set the initial condition P(0)=0\nP_0 &lt;- 0\n# Set growth rate r=0.2\nr &lt;- 0.2\n# Set the carrying capacity K  = 50\nK &lt;- 50\n# Specify the time t which we want to plot the solution\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n# Find the population at time t using the solution to the ODE\nA &lt;- (K - P_0) / P_0\nP_t &lt;- K / (1 + A * exp(-r * times))\n# Plot the solution\nplot(times, P_t, xlab = \"time\", ylab = \"Population size\")\n\n\n\n\n\n\n\n\nWhen \\(P=0\\),here specified as \\(P(0)=0\\) the population remains at 0.\n\n# Set the initial condition P(0)=1\nP_0 &lt;- 1\n# Set growth rate r = 0.2\nr &lt;- 0.2\n# Set the carrying capacity K=50\nK &lt;- 50\n# Specify the time t which we want to plot the solution\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n# Find the population at time t using the solution to the ODE\nA &lt;- (K - P_0) / P_0\nP_t &lt;- K / (1 + A * exp(-r * times))\n# Plot the solution\nplot(times, P_t, xlab = \"time\", ylab = \"Population size\")\n\n\n\n\n\n\n\n\nWith \\(P(0)=1\\) and \\(r=0.2\\), we see that the gradient of the solution is 0 when \\(P=K\\) i.e. when the population is at carrying capacity."
  },
  {
    "objectID": "calculus/systems.html",
    "href": "calculus/systems.html",
    "title": "Systems of ODE’s",
    "section": "",
    "text": "In our previous ODE models we have only had one state variable, population size \\(P\\). However, there are many instances where we wish to model the rate of change in of more than one state variable.\nFor example, modelling the rate of flow of individuals into different disease states in epidemic models or modelling the interaction between more than one population.\nIn these cases, we write on ODE for the rate of change of each state variable, these equations are a ‘system’ of ODEs. To introduce this idea, we will use a well known system of ODEs, the predator-prey model."
  },
  {
    "objectID": "calculus/systems.html#predator-prey-model",
    "href": "calculus/systems.html#predator-prey-model",
    "title": "Systems of ODE’s",
    "section": "Predator-prey model",
    "text": "Predator-prey model\nThe predator-prey model (or the Lotka-Volterra equations) are a system of ODEs that can be used to predict the population size of prey and predators through time.\nThe schematic below represents our model in the form of a flow diagram. The prey population grows in size due to births, and declines due to death by natural causes and death by predation.\nThe predator population size grows due to births as a result of predation, i.e. the predators eat the prey to survive. The predators can only die by natural causes - nothing eats the predators!\nflow diagram.\nWe can write down our assumptions from our flow diagram using words. We will write an ODE for each compartment. Therefore we will have two equations, one for prey population size and one for predator population size,\n\\[\n\\begin{aligned}\n\\mbox{prey population rate of change} & = \\mbox{births} - \\mbox{deaths}-\\mbox{predation deaths} \\\\\n\\mbox{predator population rate of change} &= + \\mbox{births via predation} -\\mbox{deaths}\n\\end{aligned}\n\\]\nWe denote \\(X\\) as the number of prey and \\(Y\\) as the number of predators. Therefore the prey population rate of change with respect to time is written as \\(\\frac{dx}{dt}\\) and the the predator population rate of change is \\(\\frac{dY}{dt}\\).\nWe assume that the prey population gives birth at a rate of \\(b\\) and dies from natural causes at a rate of \\(m\\). So we can write \\(\\alpha = b - m\\) as the overall growth rate of the prey population.\nThe prey population also suffer from deaths via predation. The number of prey removed due to predation will depend on the number of contacts between the prey and predators (\\(XY\\)), the rate of contact and the probability of successful predation given contact. We denote \\(\\beta\\) as the removal rate of prey due to predation, this parameter combines both the rate of contact and the probability of successful predation.\nPutting all this together we can write the rate of removal (deaths) of prey due to predation as:\n\\[\\beta X Y.\\]\nAs the prey population declines form predation, the predator population will grow. The number of predators which are added (via births) will depend on the number of contacts between the prey and predators and the rate of contact as before, but now the rate of addition will not be the same as the rate of removal i.e. we cannot assume that the same number of prey that are removed are also added to the predators.\nFor example, if 5 prey are eaten, that does not mean that 5 predators are then born, the rate of births due to predation occurs at a different rate but due to the same number of contacts. Therefore we introduce another parameter \\(\\delta\\) which represents the growth rate of the predator population as a result of predation.Therefore our growth (births) via predation can be written as:\n\\[\\delta X Y.\\]\nThe predator population also declines from deaths from natural causes, which we assume occurs at a rate of \\(\\gamma\\).\nWe can now write down our system of ODEs representing the rate of change of he prey and predator populations:\n\\[\n\\begin{aligned}\n\\frac{dX}{dt} & = \\alpha X-\\beta XY \\\\\n\\frac{dY}{dt} &=  \\delta XY -\\gamma Y\n\\end{aligned}\n\\]\nTo find the solution to the system of ODEs over time we will use the deSolve package in R.\nOur first task is to write an R function to describe our system of ODEs. As we now have two equations, we have several changes to include, we need to:\n\nextract two state variables \\(X\\) and \\(Y\\)\ninclude two lines for two ODEs\nreturn the two derivatives as a list.\n\nThe code below shows the R function for the predator-prey model.\n\npredator_prey &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  X &lt;- state_var[\"X\"]\n  Y &lt;- state_var[\"Y\"]\n  # Extract model parameters\n  alpha &lt;- pars[\"alpha\"]\n  beta &lt;- pars[\"beta\"]\n  delta &lt;- pars[\"delta\"]\n  gamma &lt;- pars[\"gamma\"]\n  # The differential equations\n  dX &lt;- alpha * X - beta * X * Y\n  dY &lt;- delta * X * Y - gamma * Y\n  # Return the equations as a list\n  sol &lt;- list(c(dX, dY))\n  return(sol)\n}\n\nAs before, we must specify the initial state values. We now have two initial state variables to specify, we will assume \\(X(0)=10\\) and \\(Y(0)=2\\).\n\nstate_var &lt;- c(X = 10, Y = 2)\n\nThen we must create a parameter vector, a times vector and use the ode function to find the solution. Here we will specify the parameter values as follows:\n\n\\(\\alpha =1.2\\)\n\\(\\beta = 0.5\\)\n\\(\\delta = 0.2\\)\n\\(\\gamma = 0.5\\).\n\n\npars &lt;- c(alpha = 1.2, beta = 0.5, delta = 0.2, gamma = 0.5)\n\ntimes &lt;- seq(from = 0, to = 50, by = 0.1)\n\nsolution &lt;- ode(y = state_var, times = times, func = predator_prey,\n                parms = pars, method = rk4)\nhead(solution)\n\n     time         X        Y\n[1,]  0.0 10.000000 2.000000\n[2,]  0.1 10.121234 2.327118\n[3,]  0.2 10.063833 2.709602\n[4,]  0.3  9.803984 3.145046\n[5,]  0.4  9.334477 3.623920\n[6,]  0.5  8.670826 4.128468\n\n\nThere are now three columns in our ode output, one for time and one for each of the state variables \\(X(t)\\) and \\(Y(t)\\).\nWe can plot the model output to investigate the population dynamics over time. We firstly convert the solution to a data frame so we can extract column names.\n\nsolution &lt;- as.data.frame(solution)\n\nplot(solution$time, solution$X, type = \"l\", lwd = 2,\n     ylim = c(0, 12),\n     xlab = \"Time\", ylab = \"Number\")\nlines(solution$time, solution$Y, col = \"blue\", lty = 2, lwd = 2)\nlegend(\"topleft\", c(\"Predator\", \"Prey\"), col = c(\"blue\", \"black\"),\n       lty = c(2, 1), lwd = 2, bty = \"n\")\n\n\n\n\nAs the prey population size decreases, the predator population size increases.However, when the prey population becomes too small, the predator population size decreases due to lack of resources. In this period the prey population is able to recover and increases in size.\nThen there is enough prey for the predators eat, this behaviour continues in cycle.\n\n\n\n\n\n\nExcercise\n\n\n\nBy specifying different initial state values we can investigate the model behaviour in the absence of either prey or predators. Using the code from the previous lesson, find the solution when:\n\nthere is no prey (HINT: \\(X(0)=0\\))\nthere are no predators (HINT: \\(Y(0)=0\\)).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWhen there are no prey, the predator population cannot grow. The predator population dies from natural causes until there are no predators left.\n\nstate_var &lt;- c(X = 0, Y = 2)\n\nsolution &lt;- as.data.frame(ode(y = state_var, times = times,\n                              func = predator_prey,\n                              parms = pars, method = rk4))\nplot(solution$time, solution$X, type = \"l\", lwd = 2,\n     ylim = c(0, max(solution[, c(\"X\", \"Y\")])),\n     xlab = \"Time\", ylab = \"Number\")\nlines(solution$time, solution$Y, col = \"blue\", lty = 2, lwd = 2)\n\n\n\n\nThe prey population is able to grow without predators. As this model does not include any type of self-regulation, the prey population size grows exponentially.\n\nstate_var &lt;- c(X = 10, Y = 0)\n\nsolution &lt;- as.data.frame(ode(y = state_var, times = times,\n                              func = predator_prey,\n                              parms = pars, method = rk4))\n\nplot(solution$time, solution$X, type = \"l\", lwd = 2,\n     ylim = c(0, max(solution[, c(\"X\", \"Y\")])),\n     xlab = \"Time\", ylab = \"Number\")\nlines(solution$time, solution$Y, col = \"blue\", lty = 2, lwd = 2)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "New to infectious disease modelling?",
    "section": "",
    "text": "Learning the core topics of calculus and mathematical modelling will help you understand any model.\nThese notes have been developed for learners with little to no mathematical background. The materials are split into three sections:\n\nCalculus for Modelling\nIntroduction to Infectious Disease Modelling\nR essentials (optional)\n\n\n\nHave you just entered the world of infectious disease modelling? Are you ‘not a mathematician’? Understanding a few core topics of calculus will enable you to understand a wide range of mathematical models.\nThese notes cover core calculus principles used in modelling, including:\n\ndifferentiation,\nintegration (analytical and numerical),\nordinary differential equations\nand more.\n\n\n\n\nUnderstanding the principles of developing a model will give you the tools to understand any model.\nThese notes cover key introductory topics will help you to understand more complex models :\n\nunderstanding how to write equations for simple infectious disease models,\nadding additional processes e.g. loss of immunity and demographic processes,\nsolving ODE models in R,\nhow to find the equilibrium states of ODE model,\nand more.\n\n\n\n\nThese notes cover the absolute essentials of using (base) R. Aimed at those who want to go from zero to using R within an afternoon!\n\n  \n    \n       \n  \n    \n     Linkedin\n  \n  \n    \n     Github"
  },
  {
    "objectID": "index.html#calculus-for-modelling",
    "href": "index.html#calculus-for-modelling",
    "title": "New to infectious disease modelling?",
    "section": "",
    "text": "Have you just entered the world of infectious disease modelling? Are you ‘not a mathematician’? Understanding a few core topics of calculus will enable you to understand a wide range of mathematical models.\nThese notes cover core calculus principles used in modelling, including:\n\ndifferentiation,\nintegration (analytical and numerical),\nordinary differential equations\nand more."
  },
  {
    "objectID": "index.html#introduction-to-infectious-disease-modelling",
    "href": "index.html#introduction-to-infectious-disease-modelling",
    "title": "New to infectious disease modelling?",
    "section": "",
    "text": "Understanding the principles of developing a model will give you the tools to understand any model.\nThese notes cover key introductory topics will help you to understand more complex models :\n\nunderstanding how to write equations for simple infectious disease models,\nadding additional processes e.g. loss of immunity and demographic processes,\nsolving ODE models in R,\nhow to find the equilibrium states of ODE model,\nand more."
  },
  {
    "objectID": "index.html#r-essentials",
    "href": "index.html#r-essentials",
    "title": "New to infectious disease modelling?",
    "section": "",
    "text": "These notes cover the absolute essentials of using (base) R. Aimed at those who want to go from zero to using R within an afternoon!\n\n  \n    \n       \n  \n    \n     Linkedin\n  \n  \n    \n     Github"
  },
  {
    "objectID": "modelling/events.html",
    "href": "modelling/events.html",
    "title": "Using events : vaccination",
    "section": "",
    "text": "The ‘events’ function can be used to implement changes in the model at fixed times. In this example, we illustrate how to add vaccination at fixed time points in an SIR model."
  },
  {
    "objectID": "modelling/events.html#sir-model-dynamics",
    "href": "modelling/events.html#sir-model-dynamics",
    "title": "Using events : vaccination",
    "section": "SIR model dynamics",
    "text": "SIR model dynamics\nIn this example, we assume an infection is spreading in a population represented by the Susceptible-Infected-Recovered (SIR) model.The SIR model is described by the following system of differential equations,\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = \\beta S I/N\\\\\n\\frac{dI}{dt} &= \\beta S I/N - \\gamma I \\\\\n\\frac{dR}{dt} &=\\gamma I \\\n\\end{aligned}\n\\] where \\(S\\), \\(I\\) and \\(R\\) denote the number of susceptible, infectious and recovered individuals respectively. The total population size is \\(N = S + I + R\\).The model parameters are the transmission rate \\(\\beta\\) and the recovery rate \\(\\gamma\\).\nWe assume a daily transmission rate of \\(\\beta = 1.2\\), and a recovery rate of \\(\\gamma = 1/10\\). The model solution for given one infected individual in a population of 100 is shown below.\n\nSIR_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"R\"]\n  N &lt;- S + I + R\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  # The differential equations\n  dS &lt;- -beta * S * I / N\n  dI &lt;- beta * S * I / N - gamma * I\n  dR &lt;- gamma * I\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\n\n# What are our parameter values?\npars &lt;- c(beta = 1.2, gamma = 1 / 10)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 45, by = 0.1)\n\n# What are the initial values (or conditions) of the state variables?\nI0 &lt;- 1\nN &lt;- 100\nS0 &lt;- (N - I0)\nR0 &lt;- 0\n\nstate_var &lt;- c(S = S0, I = I0, R = R0)\n\n# Solve the Susceptible Infected equations over the vector of times , time\n# with initial conditions\nsolution &lt;- as.data.frame(ode(y = state_var, times = times, func = SIR_model,\n                              parms = pars, method = rk4))\n\n\n\n\n\n\n\n\n\n\nThe epidemic peak occurs at time 6.5 with 71.04 infected individuals.\nWe wish to see the effects of vaccination at fixed time points on the dynamics of infection. To do this we will use ‘events’ in the R package deSolve."
  },
  {
    "objectID": "modelling/events.html#events",
    "href": "modelling/events.html#events",
    "title": "Using events : vaccination",
    "section": "Events",
    "text": "Events\nFirst, we must write a function that describes what happens if an event is triggered. The inputs must be the current time of the integration, the current estimated of the state variables and the parameter vector.\nIn this example, an event is vaccination. We implement a simplified vaccination process where a proportion \\(p\\) of the susceptible population is vaccinated and immediately moved to the recovered class.\n\nevent_vaccinate &lt;- function(times, state_var, parms) {\n  # Extract needed state variables\n  S &lt;- state_var[\"S\"]\n  R &lt;- state_var[\"R\"]\n\n  # Extract needed model parameters\n  p &lt;- parms[\"p\"]\n\n  # Changes to the state variable due to vaccination\n  state_var[\"S\"] &lt;- S - S * p\n  state_var[\"R\"] &lt;- R + S * p\n\n  return(state_var)\n}\n\nIn the function ode we must specify the event function and the time points at which the event should occur."
  },
  {
    "objectID": "modelling/events.html#example",
    "href": "modelling/events.html#example",
    "title": "Using events : vaccination",
    "section": "Example",
    "text": "Example\nAssuming that 20% of the susceptible population is vaccinated on day 1, 5, 7, 10 the we find the solution as follows:\n\npars &lt;- c(beta = 1.2, gamma = 1 / 10, p = 0.2)\n\nsolution &lt;- as.data.frame(ode(y = state_var, times = times, func = SIR_model,\n                              parms = pars,\n                              events = list(func = event_vaccinate,\n                                            time = c(1, 5, 7, 10))))\n\n\n\n\n\n\n\n\n\n\nThe epidemic peak now occurs at time 7 with 48.24 infected individuals.\nLet’s compare this to a much higher proportion of vaccination and set \\(p=0.8\\).\n\n\n\n\n\n\n\n\n\nThe epidemic peak now occurs at time 5 with 4.64 infected individuals.\nEvents can also be triggered by separate functions instead of occurring at fixed time points, or events can be specified in data frames. For more examples and further reading:"
  },
  {
    "objectID": "modelling/freq_dens_dependence.html",
    "href": "modelling/freq_dens_dependence.html",
    "title": "Frequency or density dependence",
    "section": "",
    "text": "Here we will learn the difference between the assumption that transmission is either frequency or density dependent and how this affects how we interpret the transmission rate \\(\\beta\\) when using proportions in numbers.\nThe first question is, what have we been assuming so far?\nRecall that we formulate our infection process as follows,\n\\[ c \\nu S p = \\beta S I/N \\]\nWe assumed that the rate of contact \\(c\\) does not increase with population size. This is know as frequency dependent transmission. The rate of infectious contacts increases with the frequency of infected individuals in the population.\nInstead, we may wish to assume that the rate of contact increases linearly with total population size \\(N\\). This is commonly referred to as density dependence. In this case we would have \\(c = k N\\), where \\(k\\) is some constant.\nWhen working with numbers, the assumption of frequency or density dependence has larger implications for the transmission rate \\(\\beta\\). If we wish to assume density dependence, we specify \\(c = k N\\), so our infection process is, \\[\n\\begin{aligned}\n(k N) \\nu S p & = (k N) \\nu S I/N  \\\\\n  &=  (k \\nu) SI \\\\\n&=  \\beta' SI.\n\\end{aligned}\n\\]\nBecause the population size \\(N\\) cancels out, our new transmission rate \\(\\beta' = k \\nu\\). The implication of this is that our transmission rate in density dependent transmission is a different dimension to our transmission rate in frequency dependence when using numbers. This means that that the value of \\(\\beta\\) is not the same.\nLet’s investigate this further with some numerical solutions."
  },
  {
    "objectID": "modelling/freq_dens_dependence.html#examples-in-r",
    "href": "modelling/freq_dens_dependence.html#examples-in-r",
    "title": "Frequency or density dependence",
    "section": "Examples in R",
    "text": "Examples in R\nWe can write two ODE model functions. One where we assume density dependent transmission SIR_numbers_dens_model and one where we assume frequency dependent transmission SIR_numbers_freq_model.\n\nSIR_numbers_dens_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"R\"]\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  # The differential equations\n  dS &lt;- -(beta * S * I)\n  dI &lt;- (beta * S * I) - gamma * I\n  dR &lt;- gamma * I\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\nSIR_numbers_freq_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"R\"]\n  N &lt;- S + I + R\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  # The differential equations\n  dS &lt;- -beta * S * I / N\n  dI &lt;- beta * S * I / N - gamma * I\n  dR &lt;- gamma * I\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n\nN &lt;- 100\nI0 &lt;- 1\nstate_var_numbers &lt;- c(S = N - I0, I = I0, R = 0)\n\n# What are our parameter values?\npars &lt;- c(beta = 0.6, gamma = 0.14)\npars_dens &lt;- c(beta = 0.6 / N, gamma = 0.14)\n\nsolution_freq_numbers &lt;- as.data.frame(ode(y = state_var_numbers, times = times,\n                                           func = SIR_numbers_freq_model,\n                                           parms = pars, method = \"rk4\"))\n\nsolution_dens_numbers &lt;- as.data.frame(ode(y = state_var_numbers, times = times,\n                                           func = SIR_numbers_dens_model,\n                                           parms = pars_dens, method = \"rk4\"))\n\npar(mfrow = c(1, 2))\nplot(solution_freq_numbers$time, solution_freq_numbers$I, col = \"darkred\",\n     lwd = 2, lty = 2, type = \"l\", ylim = c(0, N), ylab = \"Numbers\",\n     xlab = \"Time\", main =  bquote(\"Frequency dependent\" ~ beta == .(0.6)))\nplot(solution_dens_numbers$time, solution_dens_numbers$I, col = \"darkred\",\n     lwd = 2, lty = 2, type = \"l\", ylim = c(0, N), ylab = \"Numbers\",\n     xlab = \"Time\", main = bquote(\"Density dependent\" ~  beta == .(0.6 / N)))\n\n\n\n\nWe can achieve the same output when we specify \\(\\beta' = \\beta/N\\).\nWe can see this relationship when we compare our infection processes, \\[\n\\begin{aligned}\n\\beta' S I &= (\\beta/N) SI \\\\\n& =\\beta S I/N\n\\end{aligned}\n\\] We have taken some time to show these results, but there is one key message : when working with numbers, the value of the transmission rate is different for frequency or density dependent.\nThis is particularly important as published articles will use the term \\(\\beta\\) regardless of what assumption they have made about the infection process. Be cautious when comparing values of the transmission rate across different models!"
  },
  {
    "objectID": "modelling/freq_dens_dependence.html#summary-and-other-assumtptions",
    "href": "modelling/freq_dens_dependence.html#summary-and-other-assumtptions",
    "title": "Frequency or density dependence",
    "section": "Summary and other assumtptions",
    "text": "Summary and other assumtptions\nWhen might we want to assume either frequency or dependent transmission?\nIn frequency dependent transmission, the rate of contact does not increase as population density increases. Therefore sexually transmitted diseases are often assumed to have frequency dependent transmission.\nIn density dependent transmission, the rate of contact does increase as population density increases. Therefore diseases affected by livestock are often assumed to be density dependent.\nOnly two choices? The choice between either frequency or density dependence seems like an extreme one. Indeed, in reality the form of transmission may lay somewhere in the middle.\n\\[ \\beta X \\frac{Y}{N^{\\alpha}} \\] where \\(\\alpha\\) is some value between 0 and 1. If \\(\\alpha = 0\\) then we have density dependence,\n\\[\n\\begin{aligned}\n\\beta S \\frac{I}{N^{\\alpha}} &= \\beta S \\frac{I}{N^{0}} \\\\\n& =  \\beta S I,\n\\end{aligned}\n\\] and if \\(\\alpha = 1\\) then we have frequency dependence,\n\\[\n\\begin{aligned}\n\\beta S \\frac{I}{N^{\\alpha}} &= \\beta X \\frac{I}{N^{1}} \\\\\n& =  \\beta S \\frac{I}{N}.\n\\end{aligned}\n\\]\nSee this paper for an example of estimating a scaling factor for the transmission term .\nWhat about area? In our formulations of the infection process we assumed that we were working with a fixed area. We had \\(c = k N\\) but we may instead want to include the area \\(A\\), and so \\(c = k N /A\\). That is the rate of contact increases with the density of individuals in a specified area.\n\n\n\n\n\n\nA note on notation\n\n\n\nYou will see the notation \\(S\\) and \\(I\\) used for both proportions and numbers, and the notation \\(\\beta\\) used for both frequency and density dependent transmission. It is important that you understand (or seek out) the model assumptions in order to understand the model solutions and the interpretation of model parameters."
  },
  {
    "objectID": "modelling/freq_dens_dependence.html#references",
    "href": "modelling/freq_dens_dependence.html#references",
    "title": "Frequency or density dependence",
    "section": "References",
    "text": "References\nBEGON M, BENNETT M, BOWERS RG, FRENCH NP, HAZEL SM, TURNER J. A clarification of transmission terms in host-microparasite models: numbers, densities and areas. Epidemiology and Infection. 2002;129(1):147-153. doi:10.1017/S0950268802007148"
  },
  {
    "objectID": "modelling/introduction.html",
    "href": "modelling/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Mathematical models can be used to represent a version reality. They are simple representations of complex processes, but they are useful nonetheless.\nWhy do we use mathematical models?\n\nWe can use models to make predictions of future infections, or of impact of interventions\nThey help us to understand dynamics that we could not observe all at once in the ‘real world’.\nWe can model complex problems are difficult to study in the lab or field.\n\nWhat do we model?\nFor a model to be useful, we need to be able to see which factors affect which outcomes If there are too many parameters, then changing one we might not be able to see the affect This is related to the question, the model needs to be complex enough for the question but simple enough to make sense of the results\nHow do we model?\n`How we model’ is the focus of this course. We will learn to implement ordinary differential equation models to make predictions about infection spread. Take the output below for example, a classic epidemic peak.\n\n\n\n\n\n\nWhat equations are used to make this plot?\nWhat parameters are included in the equations?\nWhat assumptions are made about how infections occur?\n\nWe will learn the answers to all of these questions and more."
  },
  {
    "objectID": "modelling/NGM.html",
    "href": "modelling/NGM.html",
    "title": "Next Generation Matrix",
    "section": "",
    "text": "The Next Generation Matrix (NGM) method is used to find the analytical expression of \\(R_0\\) based on a system of ODEs. To find \\(R_0\\) using the NGM method, we will write out the transitions in and out of the infection states of our model in the form of two separate matrices:\nsuch that \\(J = F - V\\) where \\(J\\) is the Jacobian matrix for the disease states of the system of ODEs.\nThen the NGM matrix is \\(K = F V^{-1}\\) and \\(R_0\\) is the spectral radius of \\(K\\).\nFirst we will cover some of the relevant calculus background."
  },
  {
    "objectID": "modelling/NGM.html#the-matrix",
    "href": "modelling/NGM.html#the-matrix",
    "title": "Next Generation Matrix",
    "section": "The Matrix",
    "text": "The Matrix\nA matrix is a table of values. It consists of rows and columns. We refer to the numbers or values in the matrix as entries.\nFor example the matrix \\(A\\) has two columns and three rows,\n\\[A = \\begin{bmatrix}\n1 & 0.1\\\\\n4.4 & 6.2 \\\\\n5.0& 3.7 \\\\\n\\end{bmatrix}.\\]\nMatrices are used in mathematical modelling, specifically in the Next Generation Matrix method.\n\nMatrix mulipcation\nMatrices of the same size can be multiplied together. If we have matrices \\(A\\) and \\(B\\),\n\\[A = \\begin{bmatrix}\na & b\\\\\nc & d \\\\\n\\end{bmatrix}\\] and\n\\[B = \\begin{bmatrix}\ne & f\\\\\ng & h \\\\\n\\end{bmatrix}.\\]\nTo multiply matrices \\(A\\) and \\(B\\) together, we multiply and add the entries as follows,\n\\[AB = \\begin{bmatrix}\nae+bg & af+bh\\\\\nce +dg& cf+dh \\\\\n\\end{bmatrix}.\\]\n\n\nMatrix addition (and subtraction)\nTo add (or subtract) two matrices of the same size, simply add (or subtract) entries. For example,\n\\[A+B = \\begin{bmatrix}\na+e & b+f\\\\\nc+g& d+h \\\\\n\\end{bmatrix}.\\]\n\\[A-B = \\begin{bmatrix}\na-e & b-f\\\\\nc-g& d-h \\\\\n\\end{bmatrix}.\\]\n\n\nMatrix inverse\nGiven a matrix \\(A\\),\n\\[A = \\begin{bmatrix}\na & b\\\\\nc & d \\\\\n\\end{bmatrix}\\]\nthe inverse, denoted \\(A^{-1}\\) is,\n\\[A^{-1} = \\frac{1}{ad-bc}\\begin{bmatrix}\nd & -b\\\\\n-c & a \\\\\n\\end{bmatrix}.\\]\n\n\nSpectral radius\nThe spectral radius of a matrix is the value of it’s largest absolute eigenvalue. We can find the eigenvalues of a matrix by solving the equation,\n\\[\\det(K-\\lambda I)=0\\]\nwhere \\(I\\) is the identity matrix and \\(\\det\\) stands for determinant. The determinant of a 2 x 2 matrix \\(A\\) is,\n\\[\\det(A) = ad-bc,\\]\nwith\n\\[A = \\begin{bmatrix}\na & b\\\\\nc & d \\\\\n\\end{bmatrix}.\\]\nThe identity matrix \\(I\\), is a matrix consisting of 1’s along the diagonal and 0’s elsewhere. For example, a 2 x 2 identity matrix is,\n\\[I = \\begin{bmatrix}\n1 & 0\\\\\n0 & 1 \\\\\n\\end{bmatrix}.\\]\nNote that for larger matrices, such as a 3 x 3 matrix, there are separate rules for finding the determinant, multiplication etc.\nSay we want to find the eigenvalues of the matrix \\(K\\) with,\n\\[K = \\begin{bmatrix}\n4 & 8\\\\\n6 & 2 \\\\\n\\end{bmatrix}.\\]\nFirst we can find the matrix \\(K-\\lambda I\\)\n\\[ \\begin{aligned}\nK-\\lambda I &= \\begin{bmatrix}\n4 & 8\\\\\n6 & 2 \\\\\n\\end{bmatrix} -  \\begin{bmatrix}\n\\lambda & 0\\\\\n0 & \\lambda \\\\\n\\end{bmatrix}\\\\\n&=\\begin{bmatrix}\n4 - \\lambda & 8\\\\\n6 & 2-\\lambda. \\\\\n\\end{bmatrix}\n\\end{aligned} \\]\nThe determinant of this matrix is,\n\\[\\begin{aligned}\n\\det(K-\\lambda I) & = (4 - \\lambda)(2-\\lambda) - 48 \\\\\n&= 8 - 4 \\lambda - 2 \\lambda + \\lambda^2-48 \\\\\n&= \\lambda^2-6\\lambda -40\\\\\n&= (\\lambda -10)(\\lambda+4).\n\\end{aligned} \\]\nThe equation \\(\\det(K-\\lambda I)\\) is equal to 0 when \\(\\lambda = 10\\) or \\(\\lambda = -4\\). Therefore, our eigenvalues are \\(\\lambda_1 = 10\\) and \\(\\lambda_2=-4\\).\nThe spectral radius is \\(\\lambda_1 = 10\\) (the largest absolute eigenvalue)."
  },
  {
    "objectID": "modelling/NGM.html#jacobian-matrix",
    "href": "modelling/NGM.html#jacobian-matrix",
    "title": "Next Generation Matrix",
    "section": "Jacobian matrix",
    "text": "Jacobian matrix\nA Jacobian matrix for a system of ordinary differential equations (ODEs) consists of all the first order partial derivatives of the system.\nFor example, say we have the system of ODEs which represent a predator (\\(X\\)) and prey (\\(Y\\)) model of interaction,\n\\[ \\begin{aligned}\n\\frac{dX}{dt} & = \\alpha X-\\beta XY \\\\\n\\frac{dY}{dt} &=  \\delta XY -\\gamma Y\n\\end{aligned} \\]\nIf we add the following notation,\n\\[ \\begin{aligned}\n\\frac{dX}{dt} & = f_1\\\\\n\\frac{dY}{dt} &=  f_2\n\\end{aligned} \\]\nThen Jacobian matrix of the system of ODES is,\n\\[J = \\begin{bmatrix}\n\\frac{\\partial f_1}{ \\partial X} & \\frac{\\partial f_1}{ \\partial Y} \\\\\n\\frac{\\partial f_2}{ \\partial X}  & \\frac{\\partial f_2}{ \\partial Y} \\\\\n\\end{bmatrix}\\]\nwhich is,\n\\[J = \\begin{bmatrix}\n\\alpha -\\beta Y & -\\beta X  \\\\\n\\delta Y  & \\delta X -\\gamma  \\\\\n\\end{bmatrix}.\\]"
  },
  {
    "objectID": "modelling/NGM.html#seir-model-with-demography",
    "href": "modelling/NGM.html#seir-model-with-demography",
    "title": "Next Generation Matrix",
    "section": "SEIR model with demography",
    "text": "SEIR model with demography\nIn this example, we have a Susceptible - Exposed - Infectious and Recovered model described by a system of ordinary differential equations,\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = \\mu N- \\beta S I/N -\\mu S \\\\\n\\frac{dE}{dt} &= \\beta S I/N - \\sigma E - \\mu E\\\\\n\\frac{dI}{dt} &= \\sigma E - \\gamma I - \\mu I\\\\\n\\frac{dR}{dt} &=\\gamma I - \\mu R\\\\\n\\end{aligned}\n\\] Individuals move from the \\(S\\) to the \\(E\\) state via frequency dependent transmission with transmission rate \\(\\beta\\). They then move from the \\(E\\) to \\(I\\) class at a rate \\(\\sigma\\), and can recover at rate \\(\\gamma\\). Individuals can suffer natural mortality at a rate \\(\\mu\\) in any state, and all individuals are born susceptible at the same rate \\(\\mu\\)."
  },
  {
    "objectID": "modelling/NGM.html#next-generation-matrix-method",
    "href": "modelling/NGM.html#next-generation-matrix-method",
    "title": "Next Generation Matrix",
    "section": "Next Generation Matrix method",
    "text": "Next Generation Matrix method\nWe will separate out the different transitions into infection terms and all other transitions in and out of the infection states. In this model, the infection states are the exposed state \\(E\\) and the infectious state \\(I\\).\nIf we first consider the exposed state (\\(E\\)) the infection terms are :\n\n\\(\\beta S I/N\\)\n\nand all other transitions are:\n\n\\(\\sigma E\\),\n\\(\\mu E\\).\n\nIn the infectious state (\\(I\\)) we have no infection terms, all new infections go to the exposed class only. The other transitions in \\(I\\) are:\n\n\\(\\sigma E\\),\n\\(\\gamma I\\),\n\\(\\mu I\\).\n\nWe denote the new infection terms in \\(E\\) and \\(I\\) as \\(\\mathcal{F_E}\\) and \\(\\mathcal{F_I}\\) respectively:\n\n\\(\\mathcal{F_E} = \\beta S I/N\\)\n\\(\\mathcal{F_I} = 0\\)\n\nThen we find the matrix \\(F\\) by taking the partial derivatives of these terms as follows:\n\\[F = \\begin{bmatrix}\n\\frac{\\partial\\mathcal{F_E}}{\\partial E}& \\frac{\\partial \\mathcal{F_E}}{\\partial I} \\\\\n\\frac{\\partial \\mathcal{F_I}}{\\partial E}& \\frac{\\partial \\mathcal{F_I}}{\\partial I} \\\\\n\\end{bmatrix}\\]\nEvaluated at disease free equilibrium, \\(S_0=N\\), \\(E_0=0\\), \\(I_0=0\\), \\(R_0=0\\) the matrix \\(F\\) becomes,\n\\[F = \\begin{bmatrix}\n0& \\beta  \\\\\n0& 0\\\n\\end{bmatrix}.\\]\nFor the other transitions, we write the entries of the matrix \\(V\\) as the rate of individuals into a state - the rate of individuals out of the state.\nTherefore we denote other transitions out of \\(E\\):\n\n\\(\\mathcal{V_E} = \\sigma E +\\mu E,\\)\n\nand the other transitions transitions in \\(I\\) as:\n\n\\(\\mathcal{V_I} = \\gamma I +\\mu I - \\sigma E.\\)\n\nThen we we can write the matrix \\(V\\):\n\\[V = \\begin{bmatrix}\n\\frac{\\partial \\mathcal{V_E}}{\\partial E}& \\frac{\\partial \\mathcal{V_E}}{\\partial I} \\\\\n\\frac{\\partial \\mathcal{V_I}}{\\partial E}& \\frac{\\partial \\mathcal{V_I}}{\\partial I} \\\\\n\\end{bmatrix}\\]\nwhich evaluated at the disease free equilibrium becomes: \\[V = \\begin{bmatrix}\n\\sigma +\\mu & 0\\\\\n-\\sigma & \\gamma +\\mu\\\\\n\\end{bmatrix}.\\]\nThe NGM is \\(K=F V^{-1}\\), so we must find the inverse of \\(V\\):\n\\[\\begin{aligned}\nV^{-1} & = \\frac{1}{(\\sigma+\\mu)(\\gamma+\\mu)}\\begin{bmatrix}\n{\\gamma +\\mu} & 0\\\\\n\\sigma & {\\sigma +\\mu}\n\\end{bmatrix} \\\\\n& = \\begin{bmatrix}\n\\frac{1}{\\sigma +\\mu} & 0\\\\\n\\frac{\\sigma}{(\\sigma+\\mu)(\\gamma+\\mu)} & \\frac{1}{\\gamma +\\mu}\\\\\n\\end{bmatrix}\n\\end{aligned} \\]\nMultiplying \\(F\\) and \\(V^{-1}\\) gives:\n\\[FV^{-1} =\\begin{bmatrix}\n0+\\frac{\\beta\\sigma}{(\\gamma+\\mu)(\\sigma+\\mu)} & 0+\\frac{\\beta}{(\\gamma+\\mu)}\\\\\n0 +0& 0+0 \\\\\n\\end{bmatrix}.\\]\nTherefore the NGM is, \\[K =\\begin{bmatrix}\n\\frac{\\beta\\sigma}{(\\gamma+\\mu)(\\sigma+\\mu)} & \\frac{\\beta}{(\\gamma+\\mu)}\\\\\n0 & 0 \\\\\n\\end{bmatrix}.\\]\n\\(R_0\\) is the spectral radius of \\(K\\) which we find by solving the equation \\(\\det(K-\\lambda I)=0\\).\nFirstly, we find the matrix \\(K-\\lambda I\\),\n\\[K-\\lambda I =\\begin{bmatrix}\n\\frac{\\beta\\sigma}{(\\gamma+\\mu)(\\sigma+\\mu)} -\\lambda & \\frac{\\beta}{(\\gamma+\\mu)}\\\\\n0 & -\\lambda \\\\\n\\end{bmatrix}.\\]\nThen find the determinant of this matrix, \\[ \\det(K-\\lambda I) = (\\frac{\\beta\\sigma}{(\\gamma+\\mu)(\\sigma+\\mu)} -\\lambda)(-\\lambda)\\]\nThis equation equals 0 when \\(\\lambda_1 = 0\\) or \\(\\lambda_2 = \\frac{\\beta\\sigma}{(\\gamma+\\mu)(\\sigma+\\mu)}\\). \\(\\lambda_2\\) will always be the largest eigenvalue, so the expression for \\(R_0\\) for the SEIR model is:\n\\[R_0 = \\frac{\\sigma\\beta}{(\\sigma+\\mu)(\\gamma+\\mu)}. \\]"
  },
  {
    "objectID": "modelling/NGM.html#further-reading",
    "href": "modelling/NGM.html#further-reading",
    "title": "Next Generation Matrix",
    "section": "Further reading",
    "text": "Further reading\nDiekmann O., Heesterbeek J. A. P. and Roberts M. G. 2010. The construction of next-generation matrices for compartmental epidemic models. J. R. Soc. Interface.7873–885.\nP. van den Driessche and J. Watmough (2001). Reproductive numbers and sub-threshold endemic equilibria for compartment models of disease transmission, Math. Biosci., 180:29–48.\nMajid Bani-Yaghoub, Raju Gautam, Zhisheng Shuai, P. van den Driessche & Renata Ivanek (2012) Reproduction numbers for infections with free-living pathogens growing in the environment, Journal of Biological Dynamics, 6:2, 923-940."
  },
  {
    "objectID": "modelling/prop_numbers.html",
    "href": "modelling/prop_numbers.html",
    "title": "Modelling proportions or numbers",
    "section": "",
    "text": "How do you switch between modelling the proportion or numbers of individuals in different disease states? Assumptions about transmission affect our model parameter values under different outcomes of interest. Here we will cover definitions and code for Susceptible-Infectious-Recovered models where the outcome is either proportions or numbers."
  },
  {
    "objectID": "modelling/prop_numbers.html#model-assumptions",
    "href": "modelling/prop_numbers.html#model-assumptions",
    "title": "Modelling proportions or numbers",
    "section": "Model assumptions",
    "text": "Model assumptions\nOrdinary differential equation models can be used to predict the predict the proportions or the numbers of individuals in different infection states.\nAn SIR model for proportions can be described by a system of three ODEs:\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = - \\beta S I \\\\\n\\frac{dI}{dt} &= \\beta S I -\\gamma I \\\\\n\\frac{dR}{dt} &= \\gamma I\n\\end{aligned}\n\\]\nIn this model, the rate of new infections per time unit as a function of:\nthe susceptible individuals \\(S,\\) the rate of contact between susceptible and infected individuals \\(c,\\) the probability that a susceptible individual contacts an infected individual \\(p,\\) the probability of successful transmission given contact \\(\\nu\\).\nOur infection process from can be written as the product of these terms:\n\\[ c \\nu S p. \\]\nThe probability that a susceptible individual contacts an infected individual is equal to the current prevalence. Our model is going to predict the proportion of individuals in each compartment, therefore, we can use \\(p=I\\).\nThe product of the rate of contact and the probability of successful transmission given contact gives the overall transmission rate, which we denote \\(\\beta\\). Therefore, \\(\\beta=c\\nu\\).\nOur infection process can be written as:\n\\[ \\beta S I. \\]\nWe may instead wish to predict the numbers in each state. We can do this using the same equations, but with some changes to the notation.\nIf we define \\(S=X/N\\), \\(I=Y/N\\) and \\(R=Z/N\\) then we can write equations to predict numbers instead of proportions. Remember that in our formulation of infection, we assumed the probability of a susceptible contacting an infected was equal to the prevalence \\(p=I\\). As we will now be predicting with numbers, prevalence is \\(p=Y/N\\).\nTherefore our infection term changes from\n\\[ \\beta S I\\]\nto\n\\[ \\beta X \\frac{Y}{N}. \\]\nOur system of ODEs is now,\n\\[\n\\begin{aligned}\n\\frac{dX}{dt} & = - \\beta X Y/ N \\\\\n\\frac{dY}{dt} &= \\beta X Y / N -\\gamma Y \\\\\n\\frac{dZ}{dt} &= \\gamma Y\n\\end{aligned}\n\\]\nwhere \\(X\\), \\(Y\\) and \\(Z\\) represent the numbers of susceptible, infected and recovered individuals respectively."
  },
  {
    "objectID": "modelling/prop_numbers.html#in-r",
    "href": "modelling/prop_numbers.html#in-r",
    "title": "Modelling proportions or numbers",
    "section": "In R",
    "text": "In R\nTo find the solution to the SIR model predicting proportions and numbers we write two functions SIR_prop_model() and SIR_numbers_model().\n\nSIR_model_prop &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"R\"]\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  # The differential equations\n  dS &lt;- - beta * S * I\n  dI &lt;- beta * S * I - gamma * I\n  dR &lt;- gamma * I\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\nSIR_numbers_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  X &lt;- state_var[\"X\"]\n  Y &lt;- state_var[\"Y\"]\n  Z &lt;- state_var[\"Z\"]\n  N &lt;- X + Y + Z\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  # The differential equations\n  dX &lt;- -beta * X * Y / N\n  dY &lt;- beta * X * Y / N - gamma * Y\n  dZ &lt;- gamma * Y\n  # Return the equations as a list\n  sol &lt;- list(c(dX, dY, dZ))\n  return(sol)\n}\n\nWe must specify the initial sate to be proportions or numbers.\n\nstate_var_prop &lt;- c(S = 0.99, I = 0.01, R = 0)\nstate_var_numbers &lt;- c(X = 99, Y = 1, Z = 0)\n\nLet’s compare the solutions to the ODE models using either proportions and numbers and using the same parameter values and time vector. Can you see how the solutions are related to each other?\n\npars &lt;- c(beta = 0.6, gamma = 0.14)\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\nsolution_prop &lt;- as.data.frame(ode(y = state_var_prop, times = times,\n                                   func = SIR_model_prop,\n                                   parms = pars, method = rk4))\n\nsolution_numbers &lt;- as.data.frame(ode(y = state_var_numbers, times = times,\n                                      func = SIR_numbers_model,\n                                      parms = pars, method = rk4))\n\nhead(cbind(solution_prop$I, solution_numbers$Y))\n\n           [,1]     [,2]\n[1,] 0.01000000 1.000000\n[2,] 0.01571161 1.571161\n[3,] 0.02454677 2.454677\n[4,] 0.03801849 3.801849\n[5,] 0.05811241 5.811241\n[6,] 0.08710784 8.710784\n\n\nWe have \\(I(t) = Y(t) / N\\). That is, the solution of the proportion of infected individuals over time is equal to the solution of the number of infected individuals over time divided by the population size when we use the same parameter values.\nThis is not always the case, it depends on the assumptions we make about our infection process. In the next lesson we will learn about why this is the case."
  },
  {
    "objectID": "modelling/prop_numbers.html#frequency-versus-density-dependence",
    "href": "modelling/prop_numbers.html#frequency-versus-density-dependence",
    "title": "Modelling proportions or numbers",
    "section": "Frequency versus density dependence",
    "text": "Frequency versus density dependence\nIn frequency dependent transmission, the rate of infectious contacts increases with the frequency of infected individuals in the population:\n\\[ \\beta X \\frac{Y}{N}.\\]\nInstead, we may wish to assume that the rate of contact increases linearly with total constant population size \\(N\\). This is commonly referred to as density dependent transmission:\n\\[\\beta' XY.\\]\nWhen we are modelling numbers, our transmission rate in density dependent transmission is a different dimension to our transmission rate in frequency dependence. This means that that the value of \\(\\beta\\) is not the same.\nWhen we are working with proportions, then the total population size \\(N=1\\). So any assumptions about the relationship between infection and density will not affect our formulation of the infection process. Meaning, there is no difference in the transmission rate between frequency or density dependence when working with proportions.\nIn summary we have,\n\n\n\n\nFrequency dependent\nDensity dependent\n\n\n\n\nNumbers\n\\(\\beta X\\frac{Y}{N}\\)\n\\(\\beta' XY\\)\n\n\nProportions\n\\(\\beta SI\\)\n\\(\\beta SI\\)"
  },
  {
    "objectID": "modelling/prop_numbers.html#summary",
    "href": "modelling/prop_numbers.html#summary",
    "title": "Modelling proportions or numbers",
    "section": "Summary",
    "text": "Summary\nModelling proportions or numbers is straightforward to implement given appropriate initial conditions and formulation of model equations.\nIt is important to understand how our model assumptions will be affected by using proportions or numbers. The interpretation of transmission rate, and other processes, will change for the outcome being modelled.\nYou will see the notation \\(S\\) and \\(I\\) used for both proportions and numbers, and the notation \\(\\beta\\) used for both frequency and density dependent transmission. Always seek out the model assumptions in order to understand the model solutions and the interpretation of model parameters."
  },
  {
    "objectID": "modelling/R.html",
    "href": "modelling/R.html",
    "title": "Using R",
    "section": "",
    "text": "The first model we will implement in R is our Susceptible-Infected model. We have two equations representing the rate of change of the susceptible and infected population:\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = - \\beta S I/N   \\\\\n\\frac{dI}{dt} &= \\beta S I/N\n\\end{aligned}\n\\] Assume that we have a population of 100 people, and there is one infected individual. To explore the infection dynamics through time we want to find the solution using initial conditions \\(S(0)=99\\) and \\(I(0)=1\\). In the population growth example, we found the analytical solution by integrating. In this case, we will also integrate but instead of finding an equation for the solution, we will find a numerical solution.\nTo find the numerical solution, we will use ODE solvers in the R packagedeSolve. The first step is to install and load the package.\ninstall.packages(\"deSolve\")\nlibrary(deSolve)\nThe function we will use to find our numerical solution is called ode. There are a number of inputs to this function, we will need to specify the first five (remember to find the help page for the function type ?ode).\nThe first five inputs are as :\node(y, times, func, parms, method)\nLet’s look at these one a time.\nThe first input (or argument) is the initial state values for our system of ODEs. Our initial state values are \\(S(0)=99\\) and \\(I(0)=1\\). We will put these values into a vector called state_var as follows:\nstate_var &lt;- c(S = 99, I = 1)\nThe second input is the times over which we want to find our numerical solution for. The interpretation of the time depends on how we specify our parameter values, we will assume our parameters are specified on a daily timescale. To find the solution from day 0 to day 25, we specify a time vector as : times &lt;- seq(from = 0, to = 25, by = 1)\nThe third input is func, an R function which describes the system of ODE. The function itself has to be specified with three inputs:\nand the function must return a list with first element a vector of the derivative values.\nThe function below describes the system of ODEs for the SI model. It takes inputs time, state_var and pars and returns our derivatives values dS and dI in a vector.\nSI_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  N &lt;- S + I\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  # The differential equations\n  dS &lt;- - beta * S * I / N\n  dI &lt;- beta * S * I / N\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI))\n  return(sol)\n}\nThe fourth input is the vector of parameter values. In the SI model, we only have one parameter values, \\(\\beta\\). Therefore our vector of parameters values is : pars &lt;- c(beta = 0.4)\nThe fifth input is the method to be used to find the numerical solution. We will specify our method as rk4, this is Runge-Kutta 4th order integration method. This method finds a numerical approximation to solution.\nWe then can use the function ode with our inputs to find the solution to our system of ODEs:\nsolution &lt;- ode(y = state_var, times = times, func = SI_model, parms = pars,\n                method = rk4)\nhead(solution)\n\n     time        S        I\n[1,]    0 99.00000 1.000000\n[2,]    1 98.51556 1.484439\n[3,]    2 97.80165 2.198350\n[4,]    3 96.75570 3.244304\n[5,]    4 95.23631 4.763686\n[6,]    5 93.05641 6.943592\nThe solution has three columns:\nTo look at the solution over time, we can plot the solution using the plot function in R. We convert our solution to a data.frame so we can extract column names for plotting.\nsolution &lt;- as.data.frame(solution)\n\nplot(solution$time, solution$S, col = \"darkblue\", lwd = 2,\n     type = \"l\", ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\nlines(solution$time, solution$I, col = \"darkred\", lwd = 2, lty = 2)\nlegend(-0.1, 60, c(\"Susceptible\", \"Infected\"), col = c(\"darkblue\", \"darkred\"),\n       lwd = 2, lty = c(1, 2), bty = \"n\")"
  },
  {
    "objectID": "modelling/R.html#sir-model",
    "href": "modelling/R.html#sir-model",
    "title": "Using R",
    "section": "SIR model",
    "text": "SIR model\nWe can extend our R code for the SI model to find the solution to the SIR model. The SIR model is described by a system of three ODEs:\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = - \\beta S I/N  \\\\\n\\frac{dI}{dt} &= \\beta S I/N - \\gamma I \\\\\n\\frac{dR}{dt} &=\\gamma I \\\\\n\\end{aligned}\n\\] We will assume that at the start of the epidemic, there are no recoveries. Therefore our initial state will be \\(S(0)=99\\), \\(I(0)=1\\) and \\(R(0)=0\\).\nWhich inputs to ode do we need to change?\nFirstly, we must specify an additional initial state R=0 as follows, state_var &lt;- c(S = 99, I = 1, R = 0).\nWe will use the same time vector, so the input times remains the same: times &lt;- seq(from = 0, to = 50, by = 1).\nWe have one additional parameter, the recovery rate \\(\\gamma\\). Therefore we add gamma to our parameter vector: pars &lt;- c(beta = 0.6, gamma = 0.14).\nWe will need to make a few changes to our R function describing the SIR model. The inputs will remain the same, but within the function we will need to,\n\nextract our current value for the recovered state\nextract our parameter gamma\nadd a line of code describing \\(dR/dt\\)\nand finally then make sure we return our solution to R.\n\nUsing the initial state and parameter values described above, try to recreate the plot below. Using the SI_model code as your base, make the necessary changes to the R function for an SIR model and rename your function SIR_model.\n\n\n\n\n\n\nSIR model code\n\n\n\n\n\n\nSIR_model &lt;- function(time, state_var, pars){\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"R\"]\n  N &lt;- S + I + R\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  # The differential equations\n  dS &lt;- - beta * S * I/N\n  dI &lt;- beta * S * I/N - gamma * I\n  dR &lt;- gamma * I\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\n# What are our parameter values?\npars &lt;- c(beta = 0.6, gamma = 0.14)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 50, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c( S = 99, I = 1, R = 0)\n\n# Solve the SIR model \nsolution &lt;- as.data.frame(ode(y = state_var, times = times, func = SIR_model, parms = pars, method = rk4))\n\nplot(solution$time, solution$S, col = \"darkblue\", lwd = 2, \n     type = \"l\", ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\nlines(solution$time, solution$I, col = \"darkred\", lwd = 2, lty = 2)\nlines(solution$time, solution$R, col = \"darkgreen\", lwd = 2, lty = 3)\nlegend(30,60, c(\"Susceptible\", \"Infected\", \"Recovered\"), col = c(\"darkblue\", \"darkred\", \"darkgreen\"), \n       lwd = 2, lty = c(1, 2, 3), bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\nUsing the initial state and parameter values described above, use the SIR code to answer the questions in the following quiz.\n\n\n\n\n\n\nExercise\n\n\n\n\nHow many susceptible, infectious and recovered individuals (to 2 decimal places) are there at day 10?\nHow many susceptible, infectious, and recovered individuals (to 2 decimal places) are there at day 50?\nAt what day is the epidemic peak (when there are the maximum number of infectious individuals)?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nHow many susceptible, infectious and recovered individuals (to 2 decimal places) are there at day 10?\n\n\nround(solution[which(solution$time == 10),],2)\n\n   time     S     I     R\n11   10 46.85 35.69 17.46\n\n\n\nHow many susceptible, infectious, and recovered individuals (to 2 decimal places) are there at day 50?\n\n\nround(solution[which(solution$time == 50),],2)\n\n   time    S    I     R\n51   50 1.49 0.56 97.95\n\n\n\nAt what day is the epidemic peak (when there are the maximum number of infectious individuals)?\n\n\nsolution$time[which.max(solution$I)]\n\n[1] 13"
  },
  {
    "objectID": "modelling/R.html#references",
    "href": "modelling/R.html#references",
    "title": "Using R",
    "section": "References",
    "text": "References\nK. Soetaert, T. Petzoldt, R.W. Setzer. Package deSolve: solving initial value differential equations in R. J. Stat. Softw., 33 (2010), pp. 1-25"
  },
  {
    "objectID": "modelling/R0.html",
    "href": "modelling/R0.html",
    "title": "Basic reproduction number",
    "section": "",
    "text": "In this lesson we introduce the basic reproduction number (\\(R_0\\)) an important concept in modelling epidemics.\n\\(R_0\\) is the average number of cases caused by one infectious individual in a entirely susceptible population. As \\(R_0\\) is the average number of secondary cases, we have the following threshold:\nWhat about if \\(R_0 = 1\\)? Then one infectious individual will go on to infect just one other, and so the disease will be endemic, i.e. the prevalence will remain at the same level.\nHow do we find the expression for \\(R_0\\)?\nFor the SIR model, we can find an expression \\(R_0\\) using the model assumptions. For complex models, there is advanced mathematical method that can be used to find an analytical expression for \\(R_0\\) from a system of ODEs called the next generation matrix method.\nIn this course we will focus on understanding how to interpret \\(R_0\\) and its relationship with other epidemiological values."
  },
  {
    "objectID": "modelling/R0.html#the-sir-model",
    "href": "modelling/R0.html#the-sir-model",
    "title": "Basic reproduction number",
    "section": "The SIR model",
    "text": "The SIR model\nIf \\(R_0\\) is the average number of cases on infectious individual infects, then our expression for \\(R_0\\) will be a product of the rate at which the infectious individual infects susceptible multiplied by the duration of time in which they can infect.\n\\[R_0 = \\mbox{transmission rate} \\times \\mbox{duration of infection}\\]\nGiven we have just one infected person, the rate of transmission will be \\(\\beta S_0\\), where \\(S_0\\) is the initial proportion of susceptibles. But remember that we are looking at an entirely susceptible population so we can assume \\(S_0=1\\).\nThe duration of infection will be the average amount of time an individual remains infectious. this is the inverse of the recovery rate. therefore the duration of infection is \\(1/\\gamma\\).\nFor SIR model, \\(R0 = \\frac{\\beta}{\\gamma}\\).\nLet’s check that the numerical solutions behave as expected when we have \\(R_0 &lt; 1\\) and \\(R_0 &gt; 1\\). In the plots below we use the following values for \\(\\beta\\) and \\(\\gamma\\),\npars1 &lt;- c(beta = 0.6, gamma = 0.14) pars2 &lt;- c(beta = 0.6, gamma = 0.65)\n\n\n\n\n\nWhen \\(R_0 = 4.3\\), the epidemic takes of and when \\(R_0 = 0.9\\), we do not have an epidemic."
  },
  {
    "objectID": "modelling/R0.html#frequency-and-density-dependent-transmission",
    "href": "modelling/R0.html#frequency-and-density-dependent-transmission",
    "title": "Basic reproduction number",
    "section": "Frequency and density dependent transmission",
    "text": "Frequency and density dependent transmission\nDoes our expression for \\(R_0\\) change when we use numbers instead of proportions? Recall that we write \\(R_0\\) as:\n\\[R_0 = \\mbox{transmission rate} \\times \\mbox{duration of infection}\\]\nIn frequency dependent transmission, our transmission rate is just \\(\\beta\\) and in density dependent transmission we have \\(\\beta' S_0\\), where \\(S_0\\) is the initial number of susceptibles.\nWe are looking at an entirely susceptible population, therefore \\(N = X_0\\) and so we have:\n\\(\\beta N\\) for density dependent transmission .\nPutting this all together we have,\n\nfrequency dependent transmission \\(R_0 = \\frac{\\beta}{\\gamma}\\)\ndensity dependent transmission \\(R_0 = \\frac{\\beta' N}{\\gamma}\\).\n\nWhen using numbers, the expressions for \\(R_0\\) are different for either frequency or density dependent transmission. For density dependent transmission, the population size (\\(N\\)) is in the expression for \\(R_0\\). This means that for the same transmission rate and recovery rate, there will be cases when an epidemic will or won’t take off due to the size of the population."
  },
  {
    "objectID": "modelling/R0.html#effective-reproduction-number",
    "href": "modelling/R0.html#effective-reproduction-number",
    "title": "Basic reproduction number",
    "section": "Effective reproduction number",
    "text": "Effective reproduction number\nThe basic reproduction ratio is a useful concept for understand whether an epidemic will occur when an infectious individual enters a completely susceptible population. But what about populations where there is existing immunity?\nThe effective reproductive ratio (\\(R_E\\)) is the average number an infected person goes on to infect in a population where not everyone is susceptible.\n\\(R_E = S R_0\\) where \\(s\\) is the proportion of the population susceptible to infection. If \\(R_E &lt; 1\\) the infection in the population will die out.\nThe plots below show the predicted epidemic from an SIR model and the effective reproductive ratio over time. Note that the time at which \\(R_E\\) becomes less than 1, is the time at which the epidemic reaches it’s peak and starts the proportion of infected starts to decrease.\n\n\n\n\n\nThe effective reproductive ratio is very useful for understanding the current risk of infection and can be used to calculate the ‘herd immunity’ threshold as we will see in the next lesson."
  },
  {
    "objectID": "modelling/R0.html#herd-immunity-threshold",
    "href": "modelling/R0.html#herd-immunity-threshold",
    "title": "Basic reproduction number",
    "section": "Herd immunity threshold",
    "text": "Herd immunity threshold\nWe are interested in the proportion of individuals that need to be immune so that the infection dies out in the population.\nSay that the proportion of population that is immune \\(p\\), how many need to be immune in order for infection to die out?\nIf \\(p\\) are immune, then \\(1-p\\) are susceptible.\nWe know that infection will die out if the effective reproductive ratio is less than 1 $R_E &lt; 1 $, where \\(R_E = s R_0\\). \\[\n\\begin{aligned}\nR_E  &&lt; 1   \\\\\ns R_0 &&lt; 1 \\mbox{   subsitute $R_E = s R_0$}\\\\\n(1-p) R_0 &&lt; 1 \\mbox{   subsitute $s = (1-p)$}\\\\\n(1-p) &&lt; \\frac{1}{R_0} \\mbox{   rearrange}\\\\\n1- \\frac{1}{R_0} & &lt; p\n\\end{aligned}\n\\] The proportion of the population that needs to be immune for an infection to die out is \\(1-1/R_0\\).\nFor example,if \\(R_0 = 2\\), the proportion of the population that needs to be immune is \\(1-1/2 = 1/2\\) of the. For higher \\(R_0\\), a higher proportion of the population needs to be immune. For \\(R_0 = 5\\), \\(1-1/5 = 4/5\\), so 80% of the population needs to immune.\nThis is referred to as herd immunity threshold. The idea of herd immunity is that only a proportion of the population need to be immune, through vaccination for example, to protect those individuals who are not immune.\n\n\n\n\n\n\nExercise\n\n\n\n\nAssuming frequency dependent transmission in an SIR model, what is the value of \\(R_0\\) if \\(\\beta = 0.12\\) and an average infectious period of 26 days (to 2 decimal places)?\nAssuming density dependent transmission in an SIR model, if \\(R_0 = 1.75\\), \\(\\gamma = 1/7\\) and the total population size is \\(N =250\\) , what is the value of the transmission rate \\(\\beta’\\)?\nIf \\(R_0\\) = 1.25, what proportion of the population needs to be immune for the effective reproduction number to be less than 1?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\n\n\nbeta &lt;- 0.12\ngamma &lt;- 1/26\nbeta / gamma\n\n[1] 3.12\n\n\n\n\n\n\nR0 &lt;- 1.75\nN &lt;- 259\ngamma &lt;- 1 / 7\nR0 * gamma / N\n\n[1] 0.000965251\n\n\n\n\n\n\nR0 &lt;- 1.25\n1 - 1 / R0\n\n[1] 0.2"
  },
  {
    "objectID": "modelling/sensitivity.html",
    "href": "modelling/sensitivity.html",
    "title": "Sensitivity analysis",
    "section": "",
    "text": "Deciding which parameters to use, what ranges and what method of sensitivity analysis depends on the question at hand. Here we introduce the concept of sensitivity analysis of infectious disease models. Using the SEIR model, we perform sensitivity analysis of model parameters on their effect on model outcomes epidemic peak time and size using visualisations and PRCC sensitivity analysis."
  },
  {
    "objectID": "modelling/sensitivity.html#setting-up",
    "href": "modelling/sensitivity.html#setting-up",
    "title": "Sensitivity analysis",
    "section": "Setting up",
    "text": "Setting up\nFor this example, we will use the SEIR model. The model is described by a system of ordinary differential equations. Individuals move from the \\(S\\) to the \\(E\\) state via frequency dependent transmission with transmission rate \\(\\beta=0.6\\). They then move from the exposed state \\(E\\), to the infectious state \\(I\\) after the latent period \\(1/\\sigma=4\\) days. Recovery occurs on average after a period of 7 days (\\(1/\\gamma=7)\\).\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = - \\beta S I/N \\\\\n\\frac{dE}{dt} &= \\beta S I/N - \\sigma E \\\\\n\\frac{dI}{dt} &= \\sigma E - \\gamma I \\\\\n\\frac{dR}{dt} &=\\gamma I \\\\\n\\end{aligned}\n\\]\nTo set up our sensitivity analysis, the are two steps we need to consider:\n\nDefine the outcome that we will measure the effect of.\n\nThe SEIR model output gives us the number of individuals in each state \\(S\\), \\(E\\), \\(I\\) and \\(R\\) through time.\n\n\n\n\n\n\n\n\n\nUsing this model output we will extract two outcomes of interest:\n\nthe epidemic peak time,\nepidemic peak size.\n\nIn the plot above, the epidemic peak time is 52 and the epidemic peak size is 2576.\n\nDecide what ranges of parameter values to explore\n\nOur parameter ranges must be biologically realistic. For example, we think the infectious period for our study disease could range between 4 and 12 days based on estimates and studies in the published literature. There is no need to explore the infectious periods that are many months or years long, as this would not be appropriate for the disease at hand.\nIn this example, we will use the following parameter ranges in our sensitivity analysis.\n\n\n\nParameter\nDefinition\nRange\n\n\n\n\n\\(1/\\sigma\\)\nLatent period\n(2,4)\n\n\n\\(1/\\gamma\\)\nInfectious period\n(4,12)\n\n\n\\(\\beta\\)\nTransmission rate\n(0.4,0.8)"
  },
  {
    "objectID": "modelling/sensitivity.html#exploring-relationships",
    "href": "modelling/sensitivity.html#exploring-relationships",
    "title": "Sensitivity analysis",
    "section": "Exploring relationships",
    "text": "Exploring relationships\nWe will include the latent period (\\(1/\\sigma\\)), the infectious period (\\(1/\\gamma\\)) and the transmission rate (\\(\\beta\\)) in our sensitivity analysis.\nFirstly, we will explore the visual changes in our model output when we change parameter values. The first plot below shows how the SEIR model solution changes when we change the value of the latent period (\\(1/\\sigma\\)). As latent period increases, epidemic peak time is pushed forward in time. The epidemic peak size is higher for shorter latent periods.\n\n\n\n\n\n\n\n\n\nThe plot below shows the epidemic peak size and time for different values of the latent period, infectious period and transmission rate respectively. The circle indicates the fixed value. From this plot we can look at the direction of the relationship and how much the outcome changes. We see that the epidemic peak time increases for longer latent periods, whereas the peak size decreases.\nThe direction of the relationship between the model outcomes and the infectious period/transmission rate are the same. The epidemic peak time decreases for longer infectious periods and higher transmission rates. Whereas the epidemic peak size increase for longer infectious periods and higher transmission rates.\nThe plots can be used to infer whether the relationship between the outcome and the parameter is monotonic, which is a requirement for the formal sensitivity analysis in the next section.\n\n\n\n\n\n\n\n\n\nWe can also use these figures to see which parameter range has the widest range in model outcomes. The biggest range in epidemic peak time is for our given range of transmission rate. Whereas the biggest range in epidemic peak size is for our range of infectious period.\nAt this point we can ask ourselves do we need a narrower range of values for our results to be meaningful? If we see a very large range of outcome for our parameter ranges, is there any other information we can obtain to narrow what our range of values is."
  },
  {
    "objectID": "modelling/sensitivity.html#formal-sensitivity-analysis",
    "href": "modelling/sensitivity.html#formal-sensitivity-analysis",
    "title": "Sensitivity analysis",
    "section": "Formal sensitivity analysis",
    "text": "Formal sensitivity analysis\nVisualisations are very useful for understanding model behaviour for our parameter ranges. It is also useful to use methods to quantify the effect of changing input parameters on our outcomes.\nPartial rank correlation coefficient (PRCC) provides a measure of correlation between an input parameter and an outcome of interest, while accounting for changes in all other input parameters. It can be used for non-linear relationships, but must the relationships must be monotonic (the gradient remains positive or negative).\nPRCC values are between 1 and -1. A value above 0 means positive correlation and value below 0 means a negative correlation. The closer the value to 1, or -1, the stronger the correlation.\nSee Wu et al. (2013) for details on PRCC formulation.\nTo perform PRCC in R, we must complete the following steps :\n\nSimulate a range of parameter values.\n\nWe will use Latin hypercube sampling (LHS) is a sampling method that ensures that the whole range of possible values are sampled by ‘remembering’ previous samples. We will use the R package {FME} and function Latinhyper()\n\nCalculate the outcome of interest for these input parameters\n\nIn our example, we must solve the SEIR model for each combination of parameters, then extract the epidemic peak time and size\n\nUsing the parameter ranges and the outputs, calculate the PRCC\n\nIn R, we need the R package {sensitivity}. The full R script to perform the PRCC sensitivity analysis is attached as an exercise file to this lesson.\nThe results of the sensitivity analysis shown in the table below. The PRCC align with our visual check. The plots with a negative relationship resulted in a negative coefficient, and the plots with a positive relationship resulted in a positive coefficient.\n\nset.seed(200)\n# Set the ranges of parameters\npar_ranges &lt;- data.frame(min = c(2, 4, 0.4),\n                         max = c(4, 12, 0.8))\nrownames(par_ranges) &lt;- c(\"latent_period\", \"infectious_period\", \"beta\")\n\n# Create the Latin hypercube\nn &lt;- 10000\nlhs_pars &lt;- as.data.frame(Latinhyper(par_ranges, n))\n\n# Find the outcome of interest for the parameter combinations\ntimes &lt;- seq(from = 0, to = 365, by = 1)\noutput_time &lt;- matrix(nrow = n, ncol = 1)\noutput_size &lt;- matrix(nrow = n, ncol = 1)\nfor (i in 1:n){\n  # Extract parameters from Latin hypercube\n  pars &lt;- c(beta = lhs_pars$beta[i],\n            gamma = 1 / lhs_pars$infectious_period[i],\n            sigma = 1 / lhs_pars$latent_period[i])\n  # Find the model solution\n  solution &lt;- as.data.frame(ode(y = state_var, times = times,\n                                func = SEIR_model, parms = pars,\n                                method = rk4))\n  # Store the outcomes\n  output_time[i] &lt;- solution$time[which.max(solution$I)]\n  output_size[i] &lt;- solution$I[which.max(solution$I)]\n}\n\n# Perform sensitivity analysis of the two outcomes\n# Specify rank = TRUE to perform PRCC (instead of PCC)\nsens_output_time &lt;- pcc(X = lhs_pars, y = output_time, rank = TRUE)\nprint(sens_output_time)\n\nsens_output_size &lt;- pcc(X = lhs_pars, y = output_size, rank = TRUE)\nprint(sens_output_size)\n\nThe largest PRCC are for the infectious period and peak size, and the transmission rate and peak time. Recall that the largest ranges of outcomes were for these combinations of parameter and outcomes."
  },
  {
    "objectID": "modelling/sensitivity.html#summary",
    "href": "modelling/sensitivity.html#summary",
    "title": "Sensitivity analysis",
    "section": "Summary",
    "text": "Summary\nSensitivity analysis is a useful tool in infectious disease modelling to help answer a number of questions:\nIs the model behaving the way it should be? Do we need a narrower range of values for our results to be meaningful? What is the strength of the effect and what direction? How would our model results change if we used a different parameter value in our range?\nIn this example, we included all model parameters in our sensitivity analysis. There will be some cases where not all parameters are included in the sensitivity analysis. If the purpose of the sensitivity analysis is to show the effect of parameters that were altered for an analysis, for example parameters are altered in value to show the effect of interventions (with all other parameters fixed in value). then a sensitivity analysis of subset of the parameters would be suitable.\nThere are other formal methods of sensitivity analysis besides PRCC. For example, Sobol indices is a variance based sensitivity analysis which calculates sensitivity ‘indices’ by dividing up the variance of the output of a function into fractions to be attributed to inputs (Wu et al. (2013)."
  },
  {
    "objectID": "modelling/sensitivity.html#references",
    "href": "modelling/sensitivity.html#references",
    "title": "Sensitivity analysis",
    "section": "References",
    "text": "References\nWu, Jianyong, Radhika Dhingra, Manoj Gambhir, and Justin V. Remais. “Sensitivity analysis of infectious disease models: methods, advances and their application.” Journal of The Royal Society Interface 10, no. 86 (2013): 20121018."
  },
  {
    "objectID": "modelling/SI.html",
    "href": "modelling/SI.html",
    "title": "The Susceptible - Infected model",
    "section": "",
    "text": "As modellers, we specify the rate of change of our variable of interest based on our assumptions about biological processes. The key to understanding epidemic models is to understand the assumptions being made about infection spread, and the impact of these assumptions on the predicted dynamics over time."
  },
  {
    "objectID": "modelling/SI.html#the-susceptible---infected-model",
    "href": "modelling/SI.html#the-susceptible---infected-model",
    "title": "The Susceptible - Infected model",
    "section": "The Susceptible - Infected model",
    "text": "The Susceptible - Infected model\nThe first model we will introduce is the Susceptible – Infected or SI model. In this model, individuals are in one of two disease states, susceptible or infected (and infectious). We refer to these disease states as different ‘compartments’.\nThe schematic below represents our model in the form of a flow diagram. There are two compartments: ‘S’ for susceptible and ‘I’ for infected, and there is one process whereby individuals can move from ‘S’ to ‘I’, infection:\n\n\n\n\n\nTo predict the flow between the two compartments, we will use ordinary differential equations (ODEs). Here we are interested in modelling the rate of change of the number of individuals in each compartment with respect to time.\nWe will write an ODE for each compartment. Therefore we will have two equations. We have one process whereby individuals leave the ‘S’ class and those same individuals are added to the ‘I’ class:\n\\[\n\\begin{aligned}\n\\mbox{susceptible population rate of change} & = - \\mbox{infections} \\\\\n\\mbox{infected population rate of change} &= + \\mbox{infections}\n\\end{aligned}\n\\]\nWe denote the number of susceptible \\(S\\) and the number of infected individuals \\(I\\). We are interested in the rate of population change of these variable \\(S\\) and \\(I\\) over time, which we will denote \\(t\\).\nThe susceptible population rate of change with respect to time is written as \\(\\frac{dS}{dt}\\) (similarly the infected population rate of change is \\(\\frac{dI}{dt}\\)).\nIn this model, the population rate of change is defined by only one process : infection. Next we must formulate the rate of new infections per time unit as a function of:\n\nthe number of susceptible individuals (\\(S\\))\nthe probability that a susceptible contacts an infected individual (\\(p\\))\nthe rate of contact between susceptible and infected individuals (\\(c\\))\nprobability of successful transmission given contact (\\(\\nu\\))\n\nOur infection process from \\(S\\) to \\(I\\) can be written as the product of these terms:\n\\[ c \\nu S p \\] the probability that a susceptible individual contacts an infected individual is equal to the current prevalence, therefore, we can use \\(p = I/N\\).\nThe product of the rate of contact and the probability of successful transmission given contact gives the overall transmission rate, which we denote \\(\\beta\\). Therefore, \\(\\beta = c \\nu\\).\nOur infection process can be written as:\n\\[ \\beta S I \\] The individuals leave \\(S\\) at the same rate as they move to \\(I\\). Therefore we write the same terms in both \\(dS/dt\\) and \\(dI/dt\\) but with different signs to represent the loss of individuals from the susceptible class and the gain in individuals to the infected class.\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = - \\beta S I   \\\\\n\\frac{dI}{dt} &= \\beta S I\n\\end{aligned}\n\\]\nNow we will use these equations to find the predicted proportions of individuals in each class. Recall that the to find the solution to a differential equation, we integrate.\nNotation: we have state variables \\(S\\) and \\(I\\). We assume we know the numbers of individuals in \\(S\\) and \\(I\\) at time 0. If we assume there is one infected individual in a population of 100 people, we denote the initial state at time 0 as \\(S(0) = 99\\) and \\(I(0) = 1\\).\nWe have just one parameter, \\(\\beta\\).\nLater in the course, we will learn how to perform numerical integration in R, for now we will focus on understanding what output we might expect given equations.\nIn this case, what do you think the predicted numbers of susceptible individual and infected individual over time will look like?"
  },
  {
    "objectID": "modelling/SI.html#the-si-model-continued",
    "href": "modelling/SI.html#the-si-model-continued",
    "title": "The Susceptible - Infected model",
    "section": "The SI model continued",
    "text": "The SI model continued\nThe plot below shows the predicted numbers over time. We see that the number of infected individuals increases over time. As the outbreak progresses, more susceptible individuals become infected.\n\n\n\n\n\n\n\n\n\nEventually all individuals become infected. This is because in our system of ODEs there is only one process and only one direction to that process : susceptible individuals becoming infected.\nOne behaviour we can predict using the equation, is the speed at which the infection spreads. To explore this, we can look at the predicted numbers for different transmission rates \\(\\beta = 0.4\\), \\(\\beta = 0.1\\) and \\(\\beta = 1.5\\).\n\n\n\n\n\n\n\n\n\nThe higher the value of \\(\\beta\\) the quicker the infection spreads. In the next lesson, we will look at extending our model to include the possibility of recovering from infection.\n\n\n\n\n\n\nExercise\n\n\n\n\nHow many compartments are in the SI model?\nHow many parameters are in the SI model (not including total population size \\(N\\))?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThere are two compartments : susceptible and infected\nThere is one parameter, the transmission route \\(\\beta\\)."
  },
  {
    "objectID": "modelling/SIR.html",
    "href": "modelling/SIR.html",
    "title": "SIR model",
    "section": "",
    "text": "We will extend the SI model to also include the possibility of recovering from infection. We have the ‘S’ and ‘I’ compartment as before. In addition, individuals can recover from infection and move to the recovered compartment, ‘R’.\nWe extend our flow diagram to include our extra compartment ‘R’ and a flow between ‘I’ and ‘R’, representing infected individuals recovering from infection.\n\n\n\n\n\nAgain, we can write down our assumptions in words. In this model, we have one additional equation representing the rate of change of the recovered population. The recovered individuals enter the recovered population at the same rate as individuals leaving the infected population. Therefore our recoveries will have a negative sign to indicate them leaving the infected population. \\[\n\\begin{aligned}\n\\mbox{susceptible population rate of change} & = - \\mbox{infections} \\\\\n\\mbox{infected population rate of change} &= + \\mbox{infections} - \\mbox{recoveries} \\\\\n\\mbox{recovered population rate of change} &= + \\mbox{recoveries}\n\\end{aligned}\n\\]\nWe have two different processes : infection and recovery.\nWe introduce a new parameter, the recovery rate \\(\\gamma\\). The recovery rate is the inverse of the average infectious period. If the average infectious period is 7 days, then the daily recovery rate is \\(1/7\\).\nThe individuals recovering at each time step is the product the recovery rate, and the proportion of individuals in the \\(I\\) compartment at that time : \\(\\gamma I\\).\nFor infections, we have \\(\\beta S I\\) leaving \\(dS/dt\\) and entering \\(dI/dt\\).\nFor recoveries, we have \\(\\gamma I\\) leaving \\(dI/dt\\) and entering \\(dR/dt\\).\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = - \\beta S I/N  \\\\\n\\frac{dI}{dt} &= \\beta S I/N - \\gamma I \\\\\n\\frac{dR}{dt} &=\\gamma I \\\\\n\\end{aligned}\n\\]\nWhat do you think the solution to this system of ODEs will look like?\n\n\n\n\n\n\n\n\n\nThe susceptible population slowly decreases as the number of infected individuals increases. As individuals can recover, there is a peak in the number of infected individuals – this is the epidemic peak, followed by an increase in the number of recovered individuals.\nIn the next section, we will learn how to implement these models in R.\n\n\n\n\n\n\nExercise\n\n\n\n\nHow many compartments are in the SIR model?\nHow many parameters are in the SIR model (not including total population size \\(N\\))?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThere are three compartments : susceptible, infected and recovered.\nThere are two parameters, the transmission rate \\(\\beta\\) and the recovery rate \\(\\gamma\\)."
  },
  {
    "objectID": "modelling/SIRS.html",
    "href": "modelling/SIRS.html",
    "title": "Test your understanding",
    "section": "",
    "text": "So far, we have learnt how to translate assumptions about how an infection spreads into ODE models. As well as formulating your own models, you may also be given model equations which you need to understand.\nWe have been given the following equations, let’s try to figure out assumptions this model includes using only the equations.\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = \\mu N + \\omega R - \\beta S I/N - \\mu S\\\\\n\\frac{dI}{dt} &= \\beta S I/N - \\gamma I - \\mu I \\\\\n\\frac{dR}{dt} &=\\gamma I - \\mu R - \\omega R\\\\\n\\end{aligned}\n\\] By writing out the model equations in words, drawing a flow diagram, or both, can you infer what the model assumptions are?"
  },
  {
    "objectID": "modelling/SIRS.html#understanding-code",
    "href": "modelling/SIRS.html#understanding-code",
    "title": "Test your understanding",
    "section": "Understanding code",
    "text": "Understanding code\nWe have also been given the following R code to find the numerical solution, but when we try to run the code, it doesn’t work. Can you fix the code and use the output to answer the questions in the next quiz?\n\nSIRS_demography_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"Z\"]\n  N &lt;- S + I + R\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  mu &lt;- pars[\"mu\"]\n  # The differential equations\n  dS &lt;- mu * N + omega * R - beta * S * I / N - mu * S\n  dI &lt;- beta * S * I / N - gamma * I - mu * I\n  dR &lt;- gamma * I - mu * R - omega * R\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\n# What are our parameter values?\npars &lt;- c(omega = 0.01, beta = 0.6, gama = 0.14, mu = 0.01)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 250, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c(S = 99, I = 1, R = 0)\n\n# Solve the Susceptible Infected equations over the vector of times , time\n# with initial conditions\nsolution &lt;- as.data.frame(ode(y = state_var, times = times,\n                              func = SIRS_demography_model, parms = pars,\n                              method = rk4))\n\nplot(solution$time, solution$S, col = \"darkblue\", lwd = 2,\n     type = \"l\", ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\nlines(solution$time, solution$I, col = \"darkred\", lwd = 2, lty = 2)\nlines(solution$time, solution$R, col = \"darkgreen\", lwd = 2, lty = 3)\nlegend(\"topright\", c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       col = c(\"darkblue\", \"darkred\", \"darkgreen\"),\n       lwd = 2, lty = c(1, 2, 3), bty = \"n\")\n\n\nSolution\nThe errors in the code were :\n\nwithin the model function, we need to extract R &lt;- state_var[\"R\"] not R &lt;- state_var[\"Z\"]. This looks like a copy and paste mistake from a previous model.\nwithin the model function, we need to extract omega from the list of parameters. This line of code was missing, we add the line omega &lt;- pars[\"omega\"] to the model code.\nThe name of the parameter \\(\\gamma\\) did not match in the the parameter vector pars and the model function. It was spelled gama in pars. We change this is gamma.\n\nThe fixed code is :\n\nSIRS_demography_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"R\"]\n  N &lt;- S + I + R\n  # Extract model parameters\n  omega &lt;- pars[\"omega\"]\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  mu &lt;- pars[\"mu\"]\n  # The differential equations\n  dS &lt;- mu * N + omega * R - beta * S * I / N - mu * S\n  dI &lt;- beta * S * I / N - gamma * I - mu * I\n  dR &lt;- gamma * I - mu * R - omega * R\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\n# What are our parameter values?\npars &lt;- c(omega = 0.01, beta = 0.6, gamma = 0.14, mu = 0.01)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 250, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c(S = 99, I = 1, R = 0)\n\n# Solve the Susceptible Infected equations over the vector of times , time\n# with initial conditions\nsolution &lt;- as.data.frame(ode(y = state_var, times = times,\n                              func = SIRS_demography_model, parms = pars,\n                              method = rk4))\n\nplot(solution$time, solution$S, col = \"darkblue\", lwd = 2,\n     type = \"l\", ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\nlines(solution$time, solution$I, col = \"darkred\", lwd = 2, lty = 2)\nlines(solution$time, solution$R, col = \"darkgreen\", lwd = 2, lty = 3)\nlegend(\"topright\", c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       col = c(\"darkblue\", \"darkred\", \"darkgreen\"), lwd = 2, lty = c(1, 2, 3),\n       bty = \"n\")\n\n\n\n\n\n\n\n\nIn the SIRS model solution, after the epidemic peak, the recovered individuals lose their immunity and become susceptible again, resulting in a secondary peak followed by endemic infection in the population.\nWe can find the endemic equilibrium values using runsteady.\n\nequilibrium_state &lt;- runsteady(y = state_var,\n                               func = SIRS_demography_model, parms = pars)\nprint(round(equilibrium_state$y, 2))\n\n    S     I     R \n25.00  9.37 65.63 \n\n\n\n\n\n\n\n\nExercise\n\n\n\nIf you increase the rate of loss of immunity, what is the effect on the number of infectious individuals at the endemic equilibrium?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\npars &lt;- c(omega = 0.05, beta = 0.6, gamma = 0.14, mu = 0.01)\n\nequilibrium_state &lt;- runsteady(y = state_var,\n                               func = SIRS_demography_model, parms = pars)\nprint(round(equilibrium_state$y, 2))\n\n   S    I    R \n25.0 22.5 52.5 \n\n\nThe number of infectious individuals at endemic equilibrium increases."
  },
  {
    "objectID": "modelling/SIR_demography.html",
    "href": "modelling/SIR_demography.html",
    "title": "Including demography",
    "section": "",
    "text": "In this lesson we will extend the SIR model to include demographic processes. In particular, we will include births and deaths from natural causes.\nWe assume all individuals, \\(S\\), \\(I\\) or \\(R\\) can give birth and all individuals are born susceptible. We assume deaths occur from natural causes, therefore deaths will occur at the same rate in each compartment. Our model assumptions are represented in the flow diagram below.\nNotice that we now have arrows which do not always connect to other compartments, such as the deaths. This represents that once an individual dies, they do not move to another compartment.\nWe write down the our assumptions using words, \\[\n\\begin{aligned}\n\\mbox{susceptible population rate of change} & = \\mbox{births} - \\mbox{infections} - \\mbox{deaths} \\\\\n\\mbox{infected population rate of change} &= + \\mbox{infections} - \\mbox{recoveries} - \\mbox{deaths}\\\\\n\\mbox{recovered population rate of change} &= + \\mbox{recoveries} -\\mbox{deaths}\n\\end{aligned}\n\\] We only have births entering the susceptible population, and we have deaths leaving the susceptible, infected and recovered population.\nGiven we assume all individuals are born susceptible, we have flows from each of \\(S\\), \\(I\\) and \\(R\\) back into \\(S\\). If we assume individuals are born at a per capita rate \\(\\mu\\). Then the rate of new individuals born is \\(\\mu N\\).\nIndividuals who die will leave the class but also leave the system entirely. We assume that births and deaths are equal, hence we also have a per capita death rate of \\(\\mu\\). As death is from natural causes only, individuals die at the same rate from each class.\nOur system of ODEs can be written as:\n\\[\n\\begin{aligned}\n\\frac{dS}{dt} & = \\mu N- \\beta S I/N - \\mu S\\\\\n\\frac{dI}{dt} &= \\beta S I/N - \\gamma I - \\mu I \\\\\n\\frac{dR}{dt} &=\\gamma I - \\mu R\\\\\n\\end{aligned}\n\\]\nWhat will the solution to this system of ODEs look like?\nSIR_demography_model &lt;- function(time, state_var, pars) {\n  # Extract state variables\n  S &lt;- state_var[\"S\"]\n  I &lt;- state_var[\"I\"]\n  R &lt;- state_var[\"R\"]\n  N &lt;- S + I + R\n  # Extract model parameters\n  beta &lt;- pars[\"beta\"]\n  gamma &lt;- pars[\"gamma\"]\n  mu &lt;- pars[\"mu\"]\n  # The differential equations\n  dS &lt;- mu * N - beta * S * I / N - mu * S\n  dI &lt;- beta * S * I / N - gamma * I - mu * I\n  dR &lt;- gamma * I - mu * R\n  # Return the equations as a list\n  sol &lt;- list(c(dS, dI, dR))\n  return(sol)\n}\n\n# What are our parameter values?\npars &lt;- c(beta = 0.1, gamma = 0.014, mu = 0.01)\n\n# Define time to solve equations\ntimes &lt;- seq(from = 0, to = 1000, by = 1)\n\n# What are the initial values (or conditions) of the state variables?\nstate_var &lt;- c(S = 99, I = 1, R = 0)\n\n# Solve the Susceptible Infected equations over the vector of times , time\n# with initial conditions\nsolution &lt;- as.data.frame(ode(y = state_var, times = times,\n                              func = SIR_demography_model, parms = pars,\n                              method = rk4))\n\nplot(solution$time, solution$S, col = \"darkblue\", lwd = 2,\n     type = \"l\", ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\nlines(solution$time, solution$I, col = \"darkred\", lwd = 2, lty = 2)\nlines(solution$time, solution$R, col = \"darkgreen\", lwd = 2, lty = 3)\nlegend(\"topright\", c(\"Susceptible\", \"Infected\", \"Recovered\"),\n       col = c(\"darkblue\", \"darkred\", \"darkgreen\"), lwd = 2, lty = c(1, 2, 3),\n       bty = \"n\")\nWe see there is an epidemic peak followed by an endemic state. In the SIR model with no births and deaths, we saw an epidemic peak which eventually died out. In the SIR model with births and deaths, new susceptible individuals are constantly being added to our population through birth. This addition of new susceptible results in infection becoming endemic."
  },
  {
    "objectID": "modelling/SIR_demography.html#equilibrium-states",
    "href": "modelling/SIR_demography.html#equilibrium-states",
    "title": "Including demography",
    "section": "Equilibrium states",
    "text": "Equilibrium states\nAn ODE system is at equilibrium when the rate of change of all variables is 0. i.e. \\(\\frac{dS}{dt}=0\\), \\(\\frac{dI}{dt}=0\\) and \\(\\frac{dR}{dt}=0\\).\nBy setting the ODE equations to 0, in some cases we can find the analytical expression for the equilibrium state. We will denote the expressions for the equilibrium as \\(S^*\\), \\(I^*\\) and \\(R^*\\). We can use these expressions to find the value of the number of individuals infected at the endemic equilibrium.\nFor the SIR model with demography, there are two equilibrium states, either \\(\\frac{dS}{dt}=\\frac{dI}{dt}=\\frac{dR}{dt}=0\\) because there is no infection or because infection is endemic. In the infection free equilibrium the values of the number of individuals in the \\(S\\), \\(I\\) and \\(R\\) class are: \\[\n\\begin{aligned}\nS^* &= N\\\\\nI^* &= 0 \\\\\nR^*&= 0\n\\end{aligned}\n\\]\nAnd for the endemic equilibrium, \\[\n\\begin{aligned}\nS^* &=  N\\frac{1}{R_0} \\\\\nI^* &= N(R_0 - 1)\\frac{\\mu}{\\beta} \\\\\nR^* &= N(R_0 - 1)\\frac{\\gamma}{\\beta}\n\\end{aligned}\n\\]\nwhere \\(R_0 = \\beta/(\\gamma+\\mu)\\).\nUsing these equations and our parameter values, we can calculate the number of individuals in each disease state at equilibrium.\n\npars &lt;- c(beta = 0.1, gamma = 0.014, mu = 0.01)\n\nbeta &lt;- pars[[\"beta\"]]\ngamma &lt;- pars[[\"gamma\"]]\nmu &lt;- pars[[\"mu\"]]\n\nR0 &lt;- beta / (gamma + mu)\nN &lt;- 100\nS_star &lt;- N * (1 / R0)\nI_star &lt;- N * (R0 - 1) * (mu / beta)\nR_star &lt;- N * (R0 - 1) * (gamma / beta)\n\nround(c(S_star, I_star, R_star), 4)\n\n[1] 24.0000 31.6667 44.3333\n\n\nWe have found the value of the endemic prevalence without having to find the numerical solution.\nHowever, this is a simple example and you may not always have an analytical expression of the equilibrium state, in this case, how can we find the endemic prevalence?\nWe can look at our numerical solution after the the epidemic peak. The R function tail will give us the last 6 rows of the solution data.frame.\n\ntail(solution)\n\n     time  S        I        R\n996   995 24 31.66667 44.33333\n997   996 24 31.66667 44.33333\n998   997 24 31.66667 44.33333\n999   998 24 31.66667 44.33333\n1000  999 24 31.66667 44.33333\n1001 1000 24 31.66667 44.33333\n\n\nThe values of our numerical solution are close to the analytical solution but not exact. We could try finding the solution for a longer time period, but we don’t know how long do we have to run our model to find endemic equilibrium.\nWe can use the R function runsteady()in the R package rootSolve to find a numerical approximation to the equilibrium state. This function takes the inputs of the value of the initial state variables, the R function for the ODE equations and the parameters.\nThen we can extract the value of the equilibrium estimate y.\n\nlibrary(rootSolve)\nequilibrium &lt;- runsteady(y = state_var, func = SIR_demography_model,\n                         parms = pars)\nround(equilibrium$y, 4)\n\n      S       I       R \n24.0000 31.6667 44.3333 \n\n\nThe numbers are now much more similar (to 4 decimal places). This is still an approximation to the true analytical solution, so we do not expect the answers to be identical."
  },
  {
    "objectID": "modelling/SIR_demography.html#importance-of-demographic-processes",
    "href": "modelling/SIR_demography.html#importance-of-demographic-processes",
    "title": "Including demography",
    "section": "Importance of demographic processes",
    "text": "Importance of demographic processes\nWe have shown that including births and deaths in an SIR model framework results in endemic infection. We have also shown that the birth and death rate \\(\\mu\\) are in the expression for \\(R_0\\) and the endemic equilibrium.\nLet’s investigate the importance of including demographic processes by looking at the predicted epidemic for different values of \\(\\mu\\).\n\n\n\n\n\n\n\n\n\nWhen \\(\\mu\\) is low in value, the infection spreads through the population so quickly that few births and deaths have occurred in that time-scale.\nWhen \\(\\mu\\) is higher in value (\\(\\mu = 0.01\\)), the time-scale of infection is impacted by births, and so endemic infection occurs.\nFinally, when \\(\\mu = 0.1\\), the time-scale of infection is slow compared to births and deaths, and so the infection does not take off after the introduction of one infected individual.\nIf infection spreads quickly compared to the time-scale births and deaths, then demographic processes do not influence the infection dynamics. However, if infection spread is slow, then demographic processes may influence the level of endemic infection and if infection takes off at all.\nThe table below shows the values for \\(R_0\\) and the endemic equilibrium (\\(I^*\\)) for the three values of \\(\\mu\\).\n\n\n\n\\(\\mu\\)\n\\(R_0\\)\n\\(I^*\\)\n\n\n\n\n0.001\n6.7\n5.67\n\n\n0.01\n4.2\n31.67\n\n\n0.1\n0.9\n0\n\n\n\nWhen \\(\\mu = 0.1\\), \\(R_0&lt;1\\) and so infection does not take off.\nWhen \\(R_0&gt;1\\), the highest \\(R_0\\) does not lead to the highest endemic equilibrium. This is important to note, \\(R_0\\) can tell you about likelihood of infection to take off, but the endemic equilibrium tells you about long term dynamics.\nIn summary, including births and deaths is a more realistic model of reality, and allows for the possibility of endemic infection. There are many extensions you can add to demographic processes in ODE models, including:\n\ndisease induced mortality\nimmunity at birth\ninfection at birth\ncontrol measures, such as vaccination at birth.\n\n\n\n\n\n\n\nExercise\n\n\n\n\nHow many compartments are in the SIR model with demography?\nHow many parameters are in the SIR model with demography (not including total population size \\(N\\))?\nWhat are the numeric values of the endemic equilibrium state of the SIR model with demography and frequency dependent transmission with \\(\\beta=0.5\\), \\(\\gamma =0.1\\), \\(\\mu =0.05\\) and \\(N=200\\)?\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n3 compartments : susceptible, infected and recovered.\nThere are three parameters, the transmission route \\(\\beta\\), the recovery rate \\(\\gamma\\) and the birth/death rate \\(\\mu\\).\n\n\n\npars &lt;- c(beta = 0.5, gamma = 1 / 10, mu = 1 / 20)\n\nbeta &lt;- pars[[\"beta\"]]\ngamma &lt;- pars[[\"gamma\"]]\nmu &lt;- pars[[\"mu\"]]\n\nR0 &lt;- beta / (gamma + mu)\nN &lt;- 200\nS_star &lt;- N * (1 / R0)\nI_star &lt;- N * (R0 - 1) * (mu / beta)\nR_star &lt;- N * (R0 - 1) * (gamma / beta)\nc(S_star, I_star, R_star)\n\n[1] 60.00000 46.66667 93.33333"
  },
  {
    "objectID": "modelling/stochastic_discrete_time.html",
    "href": "modelling/stochastic_discrete_time.html",
    "title": "BONUS : Stochastic models",
    "section": "",
    "text": "In the previous examples, the models have been deterministic, for a set of assumptions and parameter values, there is no variation in outcome. For stochastic models, For a set of assumptions and parameter values, the outcome can be different. This can arise from stochasticity in parameter values or in chance of events happening.\nHere we will learn how to code a simple stochastic model in R. Namely, a stochastic discrete time Susceptible - Infected model."
  },
  {
    "objectID": "modelling/stochastic_discrete_time.html#r-code",
    "href": "modelling/stochastic_discrete_time.html#r-code",
    "title": "BONUS : Stochastic models",
    "section": "R code",
    "text": "R code\nThe code below shows a R function which will simulate infection spread from a discrete-time stochastic model.\nThe inputs are:\n\npars : a vector containing the model parameter values,\ninitial_state : a vector containing the initial number of the number of susceptible and infected individuals,\nn_days : the number of days we want to simulate for.\n\nThe key part of this R function is the while loop. While the current day is less than the number of days, within the loop we :\n\ncalculate the probability of infection,\nsimulate how many individuals become infected,\nstore the results of the current day,\nthen update the number of days.\n\nThese steps within the loop are repeated until the day counter is equal to n_days.\n\nSI_model &lt;- function(pars, initial_state, n_days) {\n\n  # Assign numbers in each state on day 0\n  S_t &lt;- initial_state[\"S0\"]\n  I_t &lt;- initial_state[\"I0\"]\n\n  # Total pop size\n  N &lt;- S_t + I_t\n\n  # Set up data frame to store results\n  results &lt;- data.frame(time = 0, S = S_t, I = I_t)\n\n  # Set the day counter = 1\n  day &lt;- 1\n\n  while (day &lt;= n_days) {\n\n    # Probability of infection\n    p_t &lt;- 1 - exp(-pars[\"beta\"] * I_t / N)\n\n    # How many infections\n    B_t &lt;- rbinom(1, S_t, p_t)\n\n    # Update the number of susceptible and infected individuals\n    S_t &lt;- results$S[day] - B_t\n    I_t &lt;- results$I[day] + B_t\n\n    # Store results\n    results &lt;- rbind(results, c(day, S_t, I_t))\n\n    # Increase day\n    day &lt;- day + 1\n  }\n\n  return(results)\n}"
  },
  {
    "objectID": "modelling/stochastic_discrete_time.html#simulations",
    "href": "modelling/stochastic_discrete_time.html#simulations",
    "title": "BONUS : Stochastic models",
    "section": "Simulations",
    "text": "Simulations\nTo simulate infection spread over 30 days, we will specify \\(\\beta = 0.6\\), \\(S(0)=99\\) and \\(I(0)=1\\) and n_days = 30.\n\npars &lt;- c(beta = 0.6)\ninitial_state &lt;- c(S0 = 99, I0 = 1)\n\noutput &lt;- SI_model(pars, initial_state, n_days = 30)\n\nplot(output$time, output$S, col = \"darkblue\", lwd = 2,\n     type = \"l\", ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\nlines(output$time, output$I, col = \"darkred\", lwd = 2, lty = 2, type = \"l\")\nlegend(18, 60, c(\"Susceptible\", \"Infected\"),\n       col = c(\"darkblue\", \"darkred\"),\n       lwd = 2, lty = c(1, 2), bty = \"n\")\n\n\n\n\n\n\n\n\nAs the number of susceptible decreases, the number of infected people increases - the same behaviour we would expect for a Susceptible - Infected deterministic model, but as this is a stochastic model, each time we run our R function, the result will be different.\nTo repeat the model simulation we will can use a for loop. The code below calls the model function 10 times, each time two lines are added to the plot - the number of susceptible and the number of infected individuals over time.\n\npars &lt;- c(beta = 0.6)\ninitial_state &lt;- c(S0 = 99, I0 = 1)\nn_days &lt;- 30\n\n# Create an empty plot\nplot(NA, xlim = c(0, n_days), ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\nlegend(18, 60, c(\"Susceptible\", \"Infected\"),\n       col = c(\"darkblue\", \"darkred\"),\n       lwd = 2, lty = c(1, 2), bty = \"n\")\n\n# Repeat the for loop n_sim = 10 times\nn_sims &lt;- 10\nfor (i in 1:n_sims) {\n  output &lt;- SI_model(pars, initial_state, n_days)\n  lines(output$time, output$S, col = \"darkblue\", lwd = 2,\n        type = \"l\", ylim = c(0, 100), ylab = \"Number\", xlab = \"Time\")\n  lines(output$time, output$I, col = \"darkred\", lwd = 2, lty = 2, type = \"l\")\n}\n\n\n\n\n\n\n\n\nTry changing the number of simulations n_sims and the value of the transmission rate beta to see how the model output changes."
  },
  {
    "objectID": "R_notes/extracting_information.html",
    "href": "R_notes/extracting_information.html",
    "title": "Extracting information",
    "section": "",
    "text": "R can be used to visualise and analyse different types of data. Therefore we need to understand how to handle data in R.\nWe will start with the data set called women. This data set can be loaded using the function data as follows:\n\ndata(\"women\")\n\nTo view the data set, we can use the R function View(women). This opens a new tab in our Source panel. Alternatively, we can view the first 6 rows of the data set in the console using the head function:\n\nhead(women)\n\n  height weight\n1     58    115\n2     59    117\n3     60    120\n4     61    123\n5     62    126\n6     63    129\n\n\nThe data set consists of two columns : height and weight. If you want to know more about the data set, you can visit the help page using ?women.\nThis data set is in the form of a data.frame. A data.frame stores variables of different classes in named columns and rows.\nWe will learn how to extract particular columns, rows and values from our data.frame.\nFirstly, to find the dimension (the size) of our data.frame. We will use the function dim:\n\ndim(women)\n\n[1] 15  2\n\n\nOur data consists of 15 rows and 2 columns.\nIf we want to extract particular values at certain rows and columns, we can type in the row and column number. For example, say we want the 1st row and the 1st column:\n\nwomen[1, 1]\n\n[1] 58\n\n\nOr the 7th value in the 2nd column,\n\nwomen[7, 2]\n\n[1] 132\n\n\nIt’s more likely that we will want to perform calculations, or plot just one column of the data. We can extract columns from our data in different ways.\nNote how the following three methods all give the same result.\nUsing the column number,\n\nwomen[, 1]\n\n [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72\n\n\nUse the column name in place of the number,\n\nwomen[, \"height\"]\n\n [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72\n\n\nUse the $ symbol and the column name,\n\nwomen$height\n\n [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72\n\nwomen[, \"height\"]\n\n [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72\n\n\nWe can use the first two of these methods to extract rows. Note here that the rownames are the same as the row numbers, but this might not always be the case.\n\nwomen[1, ]\n\n  height weight\n1     58    115\n\nwomen[\"1\", ]\n\n  height weight\n1     58    115\n\n\nWe can extract statistical summary information from our data set using the summary function. This function will give measures such as the mean and median for each column on the data set.\n\nsummary(women)\n\n     height         weight     \n Min.   :58.0   Min.   :115.0  \n 1st Qu.:61.5   1st Qu.:124.5  \n Median :65.0   Median :135.0  \n Mean   :65.0   Mean   :136.7  \n 3rd Qu.:68.5   3rd Qu.:148.0  \n Max.   :72.0   Max.   :164.0  \n\n\nLet’s say we want to look at sections of our data, more specifically, we want to look at the heights for women who weighed more than the average.\nWe can extract the correct column name using the $ symbol and we use the which function to find the row numbers for which the weight is more than the average, 136.7.\n\nwhich(women$weight &gt; 136.7)\n\n[1]  9 10 11 12 13 14 15\n\n\nWe can improve this code by using the R function mean to find the average, and assign this value to mean_weight:\n\nmean_weight &lt;- mean(women$weight)\nwhich(women$weight &gt; mean_weight)\n\n[1]  9 10 11 12 13 14 15\n\n\nOur final step to find the heights is to assign the row numbers to which_rows :\n\nmean_weight &lt;- mean(women$weight)\nwhich_rows &lt;- which(women$weight &gt; mean_weight)\n\nwomen[which_rows, ]\n\n   height weight\n9      66    139\n10     67    142\n11     68    146\n12     69    150\n13     70    154\n14     71    159\n15     72    164\n\n\n\n\n\n\n\n\nExercise\n\n\n\nFind the weights of women with heights less than or equal to the median height of the sample. The subset of the data set you should obtain is:\n\n\n  height weight\n1     58    115\n2     59    117\n3     60    120\n4     61    123\n5     62    126\n6     63    129\n7     64    132\n8     65    135\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFirstly, we find the median height of women in the sample and name this object median_height. Next, we find for which rows contain a height less than or equal to the median height. Finally, we extract the corresponding rows of the data frame.\n\nmedian_height &lt;- median(women$height)\nwhich_rows &lt;- which(women$height &lt;= median_height)\nwomen[which_rows, ]\n\n  height weight\n1     58    115\n2     59    117\n3     60    120\n4     61    123\n5     62    126\n6     63    129\n7     64    132\n8     65    135"
  },
  {
    "objectID": "R_notes/functions.html",
    "href": "R_notes/functions.html",
    "title": "Working with code",
    "section": "",
    "text": "R has many ready to use functions to calculate statistics and to make plots. R packages contain further functions which have been written by contributors to perform more specialised analyses.\nIn this lesson you will learn how to write your own function in R.\nTo write your own function you will need specify:\n\nthe function name\ninputs\nthe calculation/operation\noutputs\n\nThe general syntax in R appears as follows:\n\nfunction_name &lt;- function(inputs) {\n  calculation / operation\n  return(outputs)\n}\n\nLet’s start by writing a function which calculates the mean of a vector of numbers. In this case we have the following:\n\nthe function name : mean_fun\ninputs : one input, a vector of numbers x\nthe calculation/operation : find the sum of the numbers and divide by the length of the vector\noutputs : the mean value\n\nTo set up our function, we assign our function name mean_fun using\n\nmean_fun &lt;- function(x) {\n  n &lt;- length(x)\n  result &lt;- sum(x) / n\n  return(result)\n}\n\nWe run the above lines to load our function into our environment. Then we can use our new function with any vector x.\n\nx &lt;- c(4, 5, 6, 3, 3, 2, 2, 4, 5, 1)\nmean_fun(x)\n\n[1] 3.5\n\n\nWe can extend our function to return more than one output. As well as returning the mean value, we also want to return n. Therefore we specify a list of outputs to return.\n\nmean_fun &lt;- function(x) {\n  n &lt;- length(x)\n  result &lt;- sum(x) / n\n  return(list(result, n))\n}\n\nNow let’s run it again,\n\nx &lt;- c(4, 5, 6, 3, 3, 2, 2, 4, 5, 1)\nmean_fun(x)\n\n[[1]]\n[1] 3.5\n\n[[2]]\n[1] 10\n\n\nWe can extend this even further by naming the outputs in our list.\n\nmean_fun &lt;- function(x) {\n  n &lt;- length(x)\n  result &lt;- sum(x) / n\n  return(list(mean_val = result, n = n))\n}\n\nThen we assign the output to my_result and we can extract the mean using mean_val or the number of observations using n.\n\nx &lt;- c(4, 5, 6, 3, 3, 2, 2, 4, 5, 1)\nmy_result &lt;- mean_fun(x)\nmy_result$mean_val\n\n[1] 3.5\n\nmy_result$n\n\n[1] 10"
  },
  {
    "objectID": "R_notes/getting_started.html",
    "href": "R_notes/getting_started.html",
    "title": "Getting Started",
    "section": "",
    "text": "R is a free to use open source software that can be used for data visualisation and statistical analysis. RStudio is an integrated development environment - it’s a more user friendly interface for R.\nWe will start by downloading and installing these two pieces of software.\nFirst we need to install R:\n\nGo to https://www.r-project.org\nUnder the heading ‘Download’ , click on ‘CRAN’\nClick on the web-address for one of the CRAN Mirrors (The choice is not critical, but you are recommended to choose a mirror from a nearby country)\nInside the box `Download and install R’, click on Download R for your platform and follow the installation instructions\n\nNext we will install RStudio:\n\nGo to https://posit.co/downloads/\nClick on ‘Download’ under the column which says RStudio Desktop Free\nFollow the installation instructions.\n\nOnce R and RStudio have been installed on your computer, open Rstudio. You will see that the RStudio interface is made up of four panels :\n\nSource\nConsole\nEnvironment / History\nFiles / Plots / Packages / Help"
  },
  {
    "objectID": "R_notes/getting_started.html#downloading-and-installing",
    "href": "R_notes/getting_started.html#downloading-and-installing",
    "title": "Getting Started",
    "section": "",
    "text": "R is a free to use open source software that can be used for data visualisation and statistical analysis. RStudio is an integrated development environment - it’s a more user friendly interface for R.\nWe will start by downloading and installing these two pieces of software.\nFirst we need to install R:\n\nGo to https://www.r-project.org\nUnder the heading ‘Download’ , click on ‘CRAN’\nClick on the web-address for one of the CRAN Mirrors (The choice is not critical, but you are recommended to choose a mirror from a nearby country)\nInside the box `Download and install R’, click on Download R for your platform and follow the installation instructions\n\nNext we will install RStudio:\n\nGo to https://posit.co/downloads/\nClick on ‘Download’ under the column which says RStudio Desktop Free\nFollow the installation instructions.\n\nOnce R and RStudio have been installed on your computer, open Rstudio. You will see that the RStudio interface is made up of four panels :\n\nSource\nConsole\nEnvironment / History\nFiles / Plots / Packages / Help"
  },
  {
    "objectID": "R_notes/getting_started.html#the-rstudio-console",
    "href": "R_notes/getting_started.html#the-rstudio-console",
    "title": "Getting Started",
    "section": "The RStudio Console",
    "text": "The RStudio Console\nThe Console is where all your code will be evaluated.\nYou can start typing immediately into the Console. For example, try typing some basic arithmetic and pressing enter, the output should look like this:\n\n2 + 2\n\n[1] 4\n\n\nR can be used as a basic calculator, and most operations are straightforward:\nAdd :\n\n2 + 2\n\n[1] 4\n\n\nSubtract:\n\n10 - 6\n\n[1] 4\n\n\nMultiply :\n\n12 * 2\n\n[1] 24\n\n\nDivide :\n\n50 / 10\n\n[1] 5\n\n\nSquare :\n\n4 ^ 2\n\n[1] 16\n\n\nThe problem with typing directly into the R console is that you can’t edit as you type.\nInstead, we want to be able to edit our code and save our progress.\nWe do this using an R script."
  },
  {
    "objectID": "R_notes/getting_started.html#the-r-script",
    "href": "R_notes/getting_started.html#the-r-script",
    "title": "Getting Started",
    "section": "The R Script",
    "text": "The R Script\nThe Source panel is where we will edit and write our code.\nTo open a new R script go to ‘File’ then ‘New file’ then ‘R script’. Alternatively click on the icon  then select ‘R script’.\nTo save the R script, go to ‘File’ then ‘Save’, or click on the save icon .\nType 2+2 into your R script. Then, make sure the mouse pointer (cursor) is on the line you want to evaluate (it can be at the beginning, the middle, the end - it doesn’t matter!) .\nTo ‘run’ your line of code, click on the  symbol or press CTRL and Enter simultaneously (command and Enter on a Mac).\nYou will now see that your line of code has been evaluated in the R console. This is called ‘running’ a line of code.\nThe working directory is where we will save any plots we make, and store data we will be using. Once setup, the directory is the default place that our plots will be saved to. It will also be the default place that R searches for any data we want to use.\nThe working directory can be set up in two ways. We can select the folder we want to set as our working directory as follows:\n‘Session -&gt; Set Working Directory -&gt; Choose Directory…’\nThen press ‘Open’ when you find your chosen folder.\nOr, we can use the command setwd() which stands for “set working directory”. We use the function setwd() by typing the file path, for example:\nsetwd(\"C:/Users/Amanda/Documents\")\nWe will see why the working directory becomes important when we start to read in external data files and save plots. To check what your current working directory is type getwd() into the console."
  },
  {
    "objectID": "R_notes/getting_started.html#assigning-values",
    "href": "R_notes/getting_started.html#assigning-values",
    "title": "Getting Started",
    "section": "Assigning values",
    "text": "Assigning values\nWe have used the R console to perform some basic calculations such as addition and subtraction. In some cases, you will need to perform the same calculation over and over again. This is where assigning values becomes useful.\nSome animals carry and transmit diseases between the environment and humans. In this case let’s say we want to show the demographic characteristics of a population of wild rats. The data is given to us in kilograms but want it in grams.\nFor each weight, 0.23, 0.164, 0.268, 0.188, 0.299 in kilograms, we can multiple by 1000 to get the corresponding weight in grams. For the first two weights 0.23 and 0.164 we do this as follows:\n\n0.23 * 1000\n\n[1] 230\n\n0.164 * 1000\n\n[1] 164\n\n\nThis is quite an inefficient way to do this calculation! We would have to type each weight separately. Let’s improve this calculation by assigning the value 1000 to a letter,\n\na &lt;- 1000\n\nIf you run the line above, the R console does not print anything. This is because you have ‘assigned’ a the value 1000 using &lt;-, so to see what a is, you need type it into the R console.\n\na &lt;- 1000\na\n\n[1] 1000\n\n\nIf you now look at the Environment panel, you will see that we have loaded a into our global environment. This means that R will remember what a is.\nWe assigned a a value to make our calculation more efficient. Now, we can multiply each weight by a :\n\na &lt;- 1000\n0.23 * a\n\n[1] 230\n\n0.164 * a\n\n[1] 164\n\n0.268 * a\n\n[1] 268\n\n0.188 * a\n\n[1] 188\n\n0.299 * a\n\n[1] 299\n\n\nBut, we can improve the efficiency of our calculation even further by placing our weights into a vector. A vector is a basic data structure used to store a sequence of elements of the same type. In our example, we are storing numeric values in a vector named weights.\n\nweights &lt;- c(0.23, 0.164, 0.268, 0.188, 0.299)\nweights\n\n[1] 0.230 0.164 0.268 0.188 0.299\n\n\nThe c means concatenate. We are concatenating all of our weights into one vector.\nNow we can perform our calculation in fewer lines, and we can easily change either the weight vector, or if we were performing a different conversion, we can change a.\n\na &lt;- 1000\nweights &lt;- c(0.23, 0.164, 0.268, 0.188, 0.299)\nweights * a\n\n[1] 230 164 268 188 299"
  },
  {
    "objectID": "R_notes/getting_started.html#using-functions",
    "href": "R_notes/getting_started.html#using-functions",
    "title": "Getting Started",
    "section": "Using functions",
    "text": "Using functions\nIn the previous sections, we performed fairly basic calculations but R can be used to perform advanced statistical analysis. R has many built in functions that can be used to analyse data, create plots and much more.\nA functions requires one or more inputs, or ‘arguments’, and gives one or more outputs, or ‘values’.\nLet’s look at an example. Say we want to find the maximum and minimum weights in our vector. Then we can use the functions min and max with the weight vector as our argument (input):\n\nweights &lt;- c(0.23, 0.164, 0.268, 0.188, 0.299)\nmax(weights)\n\n[1] 0.299\n\nmin(weights)\n\n[1] 0.164\n\n\nIf you are unsure of what an R function is doing, then you can type ? in front of the function name into the R console, which will take you to the help page of that function.\nThe help pages describe the usage of the function and the arguments which need to be passed to the function. For example, try typing into the console?max.\nThere is a search bar which can be used to look for R functions in the Help tab of the Files / Plots / Packages / Help panel. However, if you do not know the name of the function you are looking for it can be easier to instead use a search engine.\n\n\n\n\n\n\nExercise\n\n\n\nUsing the vector of weights in the assigning values section (0.23, 0.164, 0.268, 0.188, 0.299), find the mean of the and standard deviation of the weights (in kg) to two decimal places.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe use the R functions mean and sd to find the mean and standard deviation respectively.\nWe can find the mean and standard deviation to 2 decimal places using the function round. Note that round has two inputs. The first is the vector of values and the second is the number of decimal places.\nIn the code below, note how we can concatenate already assigned objects into a new vector c(mean_val,sd_val).\n\nweights &lt;- c(0.23, 0.164, 0.268, 0.188, 0.299)\nmean_val &lt;- mean(weights)\nsd_val &lt;- sd(weights)\nround(c(mean_val, sd_val), 2)\n\n[1] 0.23 0.06"
  },
  {
    "objectID": "R_notes/packages.html",
    "href": "R_notes/packages.html",
    "title": "R packages",
    "section": "",
    "text": "In the previous sections we have used ‘built in’ R functions such as mean, max and min.\nR packages contain additional functions, written and developed by the R community. These packages can contain data sets and functions to perform specialised analysis or graphics.\nTo download an R package, click on Packages in the Files / Plots / Packages / Help panel, then click on Install package(s). The default option will be to download packages from ‘Repository (CRAN)’, this is where many R packages are uploaded to. In the ‘Packages’ box you can type the name of the package you want to download.\nTry downloading the package {RColorBrewer} by typing the package name into the ‘Packages’ box and clicking ‘Install’.\nAfter downloading an R package it will be listed under Packages in the Files / Plots / Packages / Help panel. To use the functions in a package, we must load the R package using library(packagename).\nType library(RColorBrewer) into your R script and run the line. The package will now be loaded and you can use the functions the package contains. .\n\n\n\n\n\n\nExercise\n\n\n\nA colleague has sent you some code to make a map of Brazil, but when you run their code you see that you don’t have the required package installed.\n\nmap(\"world\", \"Brazil\") # Map of Brazil\n\nError in map(\"world\", \"Brazil\"): could not find function \"map\"\n\nmap.cities(country = \"Brazil\") # Add a point for each city\n\nError in map.cities(country = \"Brazil\"): could not find function \"map.cities\"\n\n\nUsing a search engine, find the package, install it, and run the code.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nlibrary(\"maps\")\nmap(\"world\", \"Brazil\")\nmap.cities(country = \"Brazil\")"
  },
  {
    "objectID": "R_notes/plots.html",
    "href": "R_notes/plots.html",
    "title": "Basic plots",
    "section": "",
    "text": "R can be used for data analysis and manipulating data. In both of these cases, we want to be able to plot our data.\nThe code below loads in the data set women and makes a basic scatter plot of height against weight. Copy and paste this R code into your R script then run the lines. The plot below will appear in your Files / Plots / Packages / Help panel.\n\ndata(\"women\")\nplot(women$weight, women$height)\n\n\n\n\nAt the moment, our plot isn’t easy to read, the axis labels are not clear. We can improve it by changing our axis labels using xlab for changing the x axis label and ylab for changing the y axis label.\n\nplot(women$weight, women$height,\n     xlab = \"Weight (lbs)\", ylab = \"Height (in)\")\n\n\n\n\nLet’s also add a main title, to do this we use the argument main.\n\nplot(women$weight, women$height,\n     xlab = \"Weight (lbs)\", ylab = \"Height (in)\",\n     main = \"Plot of weight against height\")\n\n\n\n\nWe can change the colour of the points using col = \"blue\" and change the shape of the points using pch.\n\nplot(women$weight, women$height,\n     xlab = \"Weight (lbs)\", ylab = \"Height (in)\",\n     main = \"Plot of weight against height\",\n     pch = 19, col = \"blue\")\n\n\n\n\nTo save our plot, we can click on Export (just above the plot) and either save as Image or PDF. Select as Image. You change the name of the file in the ‘File Name:’ box.\nIf you selected a folder to be your working directory, then the plot should appear in that folder. To check what your current working director is type getwd() into the console.\n\n\n\n\n\n\nExercise\n\n\n\nThe code below loads the data set cats from the MASS package and makes a basic scatter plot of body weight against heart weight.\n\nlibrary(MASS)\nplot(cats$Bwt, cats$Hwt)\n\n\n\n\nDownload and install the package MASS then extend the code above, to recreate the plot below (hint : you can specify col and pch as one number or a vector of numbers).\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nlibrary(MASS)\nplot(cats$Bwt, cats$Hwt, pch = as.numeric(cats$Sex),\n     xlab = \"body weight (kg)\", ylab = \"heart weight (g)\",\n     col = as.numeric(cats$Sex))\nlegend(\"topleft\", legend = c(\"Female\", \"Male\"), pch = c(1, 2), col = c(1, 2))"
  },
  {
    "objectID": "R_notes/working_code.html",
    "href": "R_notes/working_code.html",
    "title": "Working with code",
    "section": "",
    "text": "When we write our code it is useful to write descriptions about what each line is doing. This is an important step if you send your code to someone else and you want them to know what you have done, or if you don’t look at your code for a while and forget what you did!\nWe can add comments to our R script using the # symbol.\n# load in the dataset women\ndata(\"women\")\nAnything written after the # symbol will not be evaluated by R as code. This means we can comment out lines of code.\n# 2 + 2\n3 + 4\n\n[1] 7\nLet’s go through one of our previous examples and add comments to our code.\n# load in the dataset women\ndata(\"women\")\n\n# find the mean weight\nmean_weight &lt;- mean(women$weight)\n# find which women had a weight more than the mean\nwhich_rows &lt;- which(women$weight &gt; mean_weight)\n\n# find corresponding weight and height for these rows\nwomen[which_rows, ]\n\n   height weight\n9      66    139\n10     67    142\n11     68    146\n12     69    150\n13     70    154\n14     71    159\n15     72    164"
  },
  {
    "objectID": "R_notes/working_code.html#debugging-code",
    "href": "R_notes/working_code.html#debugging-code",
    "title": "Working with code",
    "section": "Debugging code",
    "text": "Debugging code\nSo far you may have had some errors and warnings when you run your R code. Learning how to fix R code, either written by yourself or someone else, takes time. Practice and understanding errors will help you get quicker - but even advanced R users still make mistakes.\nLet’s look at some examples of errors in broken code and see if we can fix them.\n\nheights &lt;- c(100, 120, 90, 150, 110, )\n\nError in c(100, 120, 90, 150, 110, ): argument 6 is empty\n\n\nThe mistake here is that we have a comma “,” after 110 but no number, so R is telling is that the argument is empty. If we delete the comma, then we do not get an error:\n\nheights &lt;- c(100, 120, 90, 150, 110)\n\nNow that we have fixed the code, let’s try and plot our vector of heights.\n\nheights &lt;- c(100, 120, 90, 150, 110)\n\nhist(heights, xlab = \"heights (cm)\", xlab = \"frequency\")\n\nError in hist.default(heights, xlab = \"heights (cm)\", xlab = \"frequency\"): formal argument \"xlab\" matched by multiple actual arguments\n\n\nHere we have accidentally used the argument xlab twice and R has recognised this. Let’s change the second xlab to ylab.\n\nheights &lt;- c(100, 120, 90, 150, 110)\n\nhist(heights, xlab = \"Height (in)\", ylab = \"frequency\")\n\n\n\n\nNow our code runs without errors.\n\n\n\n\n\n\nExercise\n\n\n\nCan you fix the following code so that its runs without errors?\n\n# load in data set chicken weights\ndata(\"chickwts\")\n\n# what column names of the data set\ncolname(chickwt)\n\nError in colname(chickwt): could not find function \"colname\"\n\n# make a box plot of the weight against feed\nboxplot(weight ~ fed, data = chickwts)\n\nError in eval(predvars, data, env): object 'fed' not found\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nThe data set name was incorrect in colnames\nUse ‘colnames’ not ‘colname’\nThe column name is ‘feed’ not ‘fed’\n\n\n# load in data set chicken weights\ndata(\"chickwts\")\n# what column names of the data set\ncolnames(chickwts)\n\n[1] \"weight\" \"feed\"  \n\n# make a box plot of the weight against feed\nboxplot(weight ~ feed, data = chickwts)"
  }
]